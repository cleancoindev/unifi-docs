{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"unifi A DFO protocol powered DeFi set of tools built on top of Uniswap. Built With dfohub Uniswap V2 Protocol Open Zeppelin ERC20 Token Contracts","title":"Home"},{"location":"#unifi","text":"A DFO protocol powered DeFi set of tools built on top of Uniswap.","title":"unifi"},{"location":"#built-with","text":"dfohub Uniswap V2 Protocol Open Zeppelin ERC20 Token Contracts","title":"Built With"},{"location":"CONTRIBUTING/","text":"Contributing guidelines Table of Contents Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs Coding Style Solidity Solidity portions of the codebase adhere follow the official Solidity Styleguide JavaScript Python Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings. Documentation New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec and [Solidity Domain for Sphinx]. Documentation is generated using solidity-docgen and rendered via mkdocs . solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to an Handlebars template located at docs/solidity-docgen-templates/contract.hbs . NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve mkdocs To install mkdocs Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"","title":"Contributing guidelines"},{"location":"CONTRIBUTING/#table-of-contents","text":"Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs","title":"Table of Contents"},{"location":"CONTRIBUTING/#coding-style","text":"","title":"Coding Style"},{"location":"CONTRIBUTING/#solidity","text":"Solidity portions of the codebase adhere follow the official Solidity Styleguide","title":"Solidity"},{"location":"CONTRIBUTING/#javascript","text":"","title":"JavaScript"},{"location":"CONTRIBUTING/#python","text":"Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings.","title":"Python"},{"location":"CONTRIBUTING/#documentation","text":"New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec and [Solidity Domain for Sphinx]. Documentation is generated using solidity-docgen and rendered via mkdocs . solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to an Handlebars template located at docs/solidity-docgen-templates/contract.hbs . NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve","title":"Documentation"},{"location":"CONTRIBUTING/#mkdocs","text":"To install mkdocs Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"mkdocs"},{"location":"stableCoin/microservices/IERC20/","text":"IERC20 Functions: mint(uint256 amount) balanceOf(address account) Function: mint mint(uint256 amount) Function: balanceOf balanceOf(address account) \u2192 uint256","title":"IERC20"},{"location":"stableCoin/microservices/IERC20/#ierc20","text":"","title":"IERC20"},{"location":"stableCoin/microservices/IERC20/#functions","text":"mint(uint256 amount) balanceOf(address account)","title":"Functions:"},{"location":"stableCoin/microservices/IERC20/#function-mint","text":"mint(uint256 amount)","title":"Function: mint"},{"location":"stableCoin/microservices/IERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/","text":"IMVDFunctionalitiesManager Functions: isAuthorizedFunctionality(address functionality) Function: isAuthorizedFunctionality isAuthorizedFunctionality(address functionality) \u2192 bool","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#imvdfunctionalitiesmanager","text":"","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#functions","text":"isAuthorizedFunctionality(address functionality)","title":"Functions:"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#function-isauthorizedfunctionality","text":"isAuthorizedFunctionality(address functionality) \u2192 bool","title":"Function: isAuthorizedFunctionality"},{"location":"stableCoin/microservices/IMVDProxy/","text":"IMVDProxy Functions: getToken() getStateHolderAddress() getMVDFunctionalitiesManagerAddress() transfer(address receiver, uint256 value, address token) flushToWallet(address tokenAddress, bool is721, uint256 tokenId) Function: getToken getToken() \u2192 address Function: getStateHolderAddress getStateHolderAddress() \u2192 address Function: getMVDFunctionalitiesManagerAddress getMVDFunctionalitiesManagerAddress() \u2192 address Function: transfer transfer(address receiver, uint256 value, address token) Function: flushToWallet flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"IMVDProxy"},{"location":"stableCoin/microservices/IMVDProxy/#imvdproxy","text":"","title":"IMVDProxy"},{"location":"stableCoin/microservices/IMVDProxy/#functions","text":"getToken() getStateHolderAddress() getMVDFunctionalitiesManagerAddress() transfer(address receiver, uint256 value, address token) flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"Functions:"},{"location":"stableCoin/microservices/IMVDProxy/#function-gettoken","text":"getToken() \u2192 address","title":"Function: getToken"},{"location":"stableCoin/microservices/IMVDProxy/#function-getstateholderaddress","text":"getStateHolderAddress() \u2192 address","title":"Function: getStateHolderAddress"},{"location":"stableCoin/microservices/IMVDProxy/#function-getmvdfunctionalitiesmanageraddress","text":"getMVDFunctionalitiesManagerAddress() \u2192 address","title":"Function: getMVDFunctionalitiesManagerAddress"},{"location":"stableCoin/microservices/IMVDProxy/#function-transfer","text":"transfer(address receiver, uint256 value, address token)","title":"Function: transfer"},{"location":"stableCoin/microservices/IMVDProxy/#function-flushtowallet","text":"flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"Function: flushToWallet"},{"location":"stableCoin/microservices/IStateHolder/","text":"IStateHolder Functions: clear(string varName) setBool(string varName, bool val) getBool(string varName) Function: clear clear(string varName) \u2192 string oldDataType, bytes oldVal Function: setBool setBool(string varName, bool val) \u2192 bool Function: getBool getBool(string varName) \u2192 bool","title":"IStateHolder"},{"location":"stableCoin/microservices/IStateHolder/#istateholder","text":"","title":"IStateHolder"},{"location":"stableCoin/microservices/IStateHolder/#functions","text":"clear(string varName) setBool(string varName, bool val) getBool(string varName)","title":"Functions:"},{"location":"stableCoin/microservices/IStateHolder/#function-clear","text":"clear(string varName) \u2192 string oldDataType, bytes oldVal","title":"Function: clear"},{"location":"stableCoin/microservices/IStateHolder/#function-setbool","text":"setBool(string varName, bool val) \u2192 bool","title":"Function: setBool"},{"location":"stableCoin/microservices/IStateHolder/#function-getbool","text":"getBool(string varName) \u2192 bool","title":"Function: getBool"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/","text":"MintNewVotingTokensForStableCoinFunctionality This contract adds unifi minting capabilies to uSD Functions: onStart(address, address) onStop(address) mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver) Function: onStart onStart(address, address) Function: onStop onStop(address) Function: mintNewVotingTokensForStableCoin mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"MintNewVotingTokensForStableCoinFunctionality"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#mintnewvotingtokensforstablecoinfunctionality","text":"This contract adds unifi minting capabilies to uSD","title":"MintNewVotingTokensForStableCoinFunctionality"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#functions","text":"onStart(address, address) onStop(address) mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"Functions:"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-onstart","text":"onStart(address, address)","title":"Function: onStart"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-onstop","text":"onStop(address)","title":"Function: onStop"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-mintnewvotingtokensforstablecoin","text":"mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"Function: mintNewVotingTokensForStableCoin"},{"location":"stableCoin/standalone/Address/","text":"Address Collection of functions related to the address type Functions:","title":"Address"},{"location":"stableCoin/standalone/Address/#address","text":"Collection of functions related to the address type","title":"Address"},{"location":"stableCoin/standalone/Address/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/Context/","text":"Context Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with GSN meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts. Functions:","title":"Context"},{"location":"stableCoin/standalone/Context/#context","text":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with GSN meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","title":"Context"},{"location":"stableCoin/standalone/Context/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/ERC20/","text":"ERC20 Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning false on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}. Functions: name() symbol() decimals() totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) increaseAllowance(address spender, uint256 addedValue) decreaseAllowance(address spender, uint256 subtractedValue) Function: name name() \u2192 string Description Returns the name of the token. Function: symbol symbol() \u2192 string Description Returns the symbol of the token, usually a shorter version of the name. Function: decimals decimals() \u2192 uint8 Description Returns the number of decimals used to get its user representation. For example, if decimals equals 2 , a balance of 505 tokens should be displayed to a user as 5,05 ( 505 / 10 ** 2 ). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless { setupDecimals} is called. NOTE: This information is only used for _display purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}. Function: totalSupply totalSupply() \u2192 uint256 Description See {IERC20-totalSupply}. Function: balanceOf balanceOf(address account) \u2192 uint256 Description See {IERC20-balanceOf}. Function: transfer transfer(address recipient, uint256 amount) \u2192 bool Description See {IERC20-transfer}. Requirements: - recipient cannot be the zero address. - the caller must have a balance of at least amount . Function: allowance allowance(address owner, address spender) \u2192 uint256 Description See {IERC20-allowance}. Function: approve approve(address spender, uint256 amount) \u2192 bool Description See {IERC20-approve}. Requirements: - spender cannot be the zero address. Function: transferFrom transferFrom(address sender, address recipient, uint256 amount) \u2192 bool Description See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - sender and recipient cannot be the zero address. - sender must have a balance of at least amount . - the caller must have allowance for sender 's tokens of at least amount . Function: increaseAllowance increaseAllowance(address spender, uint256 addedValue) \u2192 bool Description Atomically increases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. Function: decreaseAllowance decreaseAllowance(address spender, uint256 subtractedValue) \u2192 bool Description Atomically decreases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. - spender must have allowance for the caller of at least subtractedValue .","title":"ERC20"},{"location":"stableCoin/standalone/ERC20/#erc20","text":"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning false on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.","title":"ERC20"},{"location":"stableCoin/standalone/ERC20/#functions","text":"name() symbol() decimals() totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) increaseAllowance(address spender, uint256 addedValue) decreaseAllowance(address spender, uint256 subtractedValue)","title":"Functions:"},{"location":"stableCoin/standalone/ERC20/#function-name","text":"name() \u2192 string","title":"Function: name"},{"location":"stableCoin/standalone/ERC20/#description","text":"Returns the name of the token.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-symbol","text":"symbol() \u2192 string","title":"Function: symbol"},{"location":"stableCoin/standalone/ERC20/#description_1","text":"Returns the symbol of the token, usually a shorter version of the name.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-decimals","text":"decimals() \u2192 uint8","title":"Function: decimals"},{"location":"stableCoin/standalone/ERC20/#description_2","text":"Returns the number of decimals used to get its user representation. For example, if decimals equals 2 , a balance of 505 tokens should be displayed to a user as 5,05 ( 505 / 10 ** 2 ). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless { setupDecimals} is called. NOTE: This information is only used for _display purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/ERC20/#description_3","text":"See {IERC20-totalSupply}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/ERC20/#description_4","text":"See {IERC20-balanceOf}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-transfer","text":"transfer(address recipient, uint256 amount) \u2192 bool","title":"Function: transfer"},{"location":"stableCoin/standalone/ERC20/#description_5","text":"See {IERC20-transfer}. Requirements: - recipient cannot be the zero address. - the caller must have a balance of at least amount .","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-allowance","text":"allowance(address owner, address spender) \u2192 uint256","title":"Function: allowance"},{"location":"stableCoin/standalone/ERC20/#description_6","text":"See {IERC20-allowance}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-approve","text":"approve(address spender, uint256 amount) \u2192 bool","title":"Function: approve"},{"location":"stableCoin/standalone/ERC20/#description_7","text":"See {IERC20-approve}. Requirements: - spender cannot be the zero address.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-transferfrom","text":"transferFrom(address sender, address recipient, uint256 amount) \u2192 bool","title":"Function: transferFrom"},{"location":"stableCoin/standalone/ERC20/#description_8","text":"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - sender and recipient cannot be the zero address. - sender must have a balance of at least amount . - the caller must have allowance for sender 's tokens of at least amount .","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-increaseallowance","text":"increaseAllowance(address spender, uint256 addedValue) \u2192 bool","title":"Function: increaseAllowance"},{"location":"stableCoin/standalone/ERC20/#description_9","text":"Atomically increases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-decreaseallowance","text":"decreaseAllowance(address spender, uint256 subtractedValue) \u2192 bool","title":"Function: decreaseAllowance"},{"location":"stableCoin/standalone/ERC20/#description_10","text":"Atomically decreases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. - spender must have allowance for the caller of at least subtractedValue .","title":"Description"},{"location":"stableCoin/standalone/IDoubleProxy/","text":"IDoubleProxy Functions: proxy() Function: proxy proxy() \u2192 address","title":"IDoubleProxy"},{"location":"stableCoin/standalone/IDoubleProxy/#idoubleproxy","text":"","title":"IDoubleProxy"},{"location":"stableCoin/standalone/IDoubleProxy/#functions","text":"proxy()","title":"Functions:"},{"location":"stableCoin/standalone/IDoubleProxy/#function-proxy","text":"proxy() \u2192 address","title":"Function: proxy"},{"location":"stableCoin/standalone/IERC20/","text":"IERC20 Interface of the ERC20 standard as defined in the EIP. Functions: totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) Events: Transfer(address from, address to, uint256 value) Approval(address owner, address spender, uint256 value) Function: totalSupply totalSupply() \u2192 uint256 Description Returns the amount of tokens in existence. Function: balanceOf balanceOf(address account) \u2192 uint256 Description Returns the amount of tokens owned by account . Function: transfer transfer(address recipient, uint256 amount) \u2192 bool Description Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event. Function: allowance allowance(address owner, address spender) \u2192 uint256 Description Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called. Function: approve approve(address spender, uint256 amount) \u2192 bool Description Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event. Function: transferFrom transferFrom(address sender, address recipient, uint256 amount) \u2192 bool Description Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event. Event: Transfer Transfer(address from, address to, uint256 value) Description Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero. Event: Approval Approval(address owner, address spender, uint256 value) Description Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"IERC20"},{"location":"stableCoin/standalone/IERC20/#ierc20","text":"Interface of the ERC20 standard as defined in the EIP.","title":"IERC20"},{"location":"stableCoin/standalone/IERC20/#functions","text":"totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/IERC20/#events","text":"Transfer(address from, address to, uint256 value) Approval(address owner, address spender, uint256 value)","title":"Events:"},{"location":"stableCoin/standalone/IERC20/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/IERC20/#description","text":"Returns the amount of tokens in existence.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/IERC20/#description_1","text":"Returns the amount of tokens owned by account .","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-transfer","text":"transfer(address recipient, uint256 amount) \u2192 bool","title":"Function: transfer"},{"location":"stableCoin/standalone/IERC20/#description_2","text":"Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-allowance","text":"allowance(address owner, address spender) \u2192 uint256","title":"Function: allowance"},{"location":"stableCoin/standalone/IERC20/#description_3","text":"Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-approve","text":"approve(address spender, uint256 amount) \u2192 bool","title":"Function: approve"},{"location":"stableCoin/standalone/IERC20/#description_4","text":"Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-transferfrom","text":"transferFrom(address sender, address recipient, uint256 amount) \u2192 bool","title":"Function: transferFrom"},{"location":"stableCoin/standalone/IERC20/#description_5","text":"Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#event-transfer","text":"Transfer(address from, address to, uint256 value)","title":"Event: Transfer"},{"location":"stableCoin/standalone/IERC20/#description_6","text":"Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#event-approval","text":"Approval(address owner, address spender, uint256 value)","title":"Event: Approval"},{"location":"stableCoin/standalone/IERC20/#description_7","text":"Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"Description"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/","text":"IMVDFunctionalitiesManager Functions: isAuthorizedFunctionality(address functionality) Function: isAuthorizedFunctionality isAuthorizedFunctionality(address functionality) \u2192 bool","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#imvdfunctionalitiesmanager","text":"","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#functions","text":"isAuthorizedFunctionality(address functionality)","title":"Functions:"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#function-isauthorizedfunctionality","text":"isAuthorizedFunctionality(address functionality) \u2192 bool","title":"Function: isAuthorizedFunctionality"},{"location":"stableCoin/standalone/IMVDProxy/","text":"IMVDProxy Functions: getToken() getMVDFunctionalitiesManagerAddress() getMVDWalletAddress() getStateHolderAddress() submit(string codeName, bytes data) Function: getToken getToken() \u2192 address Function: getMVDFunctionalitiesManagerAddress getMVDFunctionalitiesManagerAddress() \u2192 address Function: getMVDWalletAddress getMVDWalletAddress() \u2192 address Function: getStateHolderAddress getStateHolderAddress() \u2192 address Function: submit submit(string codeName, bytes data) \u2192 bytes returnData","title":"IMVDProxy"},{"location":"stableCoin/standalone/IMVDProxy/#imvdproxy","text":"","title":"IMVDProxy"},{"location":"stableCoin/standalone/IMVDProxy/#functions","text":"getToken() getMVDFunctionalitiesManagerAddress() getMVDWalletAddress() getStateHolderAddress() submit(string codeName, bytes data)","title":"Functions:"},{"location":"stableCoin/standalone/IMVDProxy/#function-gettoken","text":"getToken() \u2192 address","title":"Function: getToken"},{"location":"stableCoin/standalone/IMVDProxy/#function-getmvdfunctionalitiesmanageraddress","text":"getMVDFunctionalitiesManagerAddress() \u2192 address","title":"Function: getMVDFunctionalitiesManagerAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-getmvdwalletaddress","text":"getMVDWalletAddress() \u2192 address","title":"Function: getMVDWalletAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-getstateholderaddress","text":"getStateHolderAddress() \u2192 address","title":"Function: getStateHolderAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-submit","text":"submit(string codeName, bytes data) \u2192 bytes returnData","title":"Function: submit"},{"location":"stableCoin/standalone/IStableCoin/","text":"IStableCoin Define the interface for the usD Functions: init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount) Function: init init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Description Constructor signature Parameters: name : name of the StableCoin ERC20 token symbol : ticker for the StableCoin ERC20 token doubleProxy : address for the DoubleProxy allowedPairs : array of Uniswap Pairs to be set as whitelisted source tokens rebalanceRewardMultiplier : multiplier used to compute how many unifi tokens to mint during uSD rebalance timeWindows : time windows inside which some time-delimited operations can be performed mintables : max amount of mintables inside a timeWindow Function: allowedPairs allowedPairs() \u2192 address[] Return Values: Array of allowed Uniswap pairs Function: availableToMint availableToMint() \u2192 uint256 mintable Return Values: mintable The amount of available mintable token Function: differences differences() \u2192 uint256, uint256 Function: doubleProxy doubleProxy() \u2192 address Return Values: The address for the doubleProxy smart contract Function: rebalanceRewardMultiplier rebalanceRewardMultiplier() \u2192 uint256[] Return Values: The multiplier used to compute the rebalancing rewards Function: tierData tierData() \u2192 uint256[], uint256[] Return Values: All tiers of data of the carried context Function: setAllowedPairs setAllowedPairs(address[] newAllowedPairs) Parameters: newAllowedPairs : list of Uniswap pairs to be whitelisted Function: setDoubleProxy setDoubleProxy(address newDoubleProxy) Parameters: newDoubleProxy : new DoubleProxy to set Function: calculateRebalanceByDebtReward calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward Description Compute the reward of the rebalanceByDebt() operation. Parameters: burnt : amount of of uSD burnt Function: fromTokenToStable fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256 Description Convert from one of the allowed whitelisted tokens to uSD Parameters: tokenAddress : Address of the token to convert amount : Amount of Unifi token to be converted Return Values: Amount of uSD tokens Function: mint mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 Description Mint the uSD token Parameters: pairIndex : Index of the pair inside the allowedPairs array amountA : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates) amountB : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates) amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired Return Values: Amount of freshly minted uSD token Function: burn burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 amountA, uint256 amountB Description Mint the uSD token Parameters: pairIndex : Index of the pair inside the allowedPairs array amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert Return Values: amountA The amount of tokenA received amountB The amount of tokenB received Function: rebalanceByCredit rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed Description Rebalance by Credit is triggered when the total amount of source tokens' value is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool. Function: rebalanceByDebt rebalanceByDebt(uint256 amount) \u2192 uint256 Description Rebalance by Credit is triggered when the total amount of source tokens' value is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"IStableCoin"},{"location":"stableCoin/standalone/IStableCoin/#istablecoin","text":"Define the interface for the usD","title":"IStableCoin"},{"location":"stableCoin/standalone/IStableCoin/#functions","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/IStableCoin/#function-init","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: init"},{"location":"stableCoin/standalone/IStableCoin/#description","text":"Constructor signature","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters","text":"name : name of the StableCoin ERC20 token symbol : ticker for the StableCoin ERC20 token doubleProxy : address for the DoubleProxy allowedPairs : array of Uniswap Pairs to be set as whitelisted source tokens rebalanceRewardMultiplier : multiplier used to compute how many unifi tokens to mint during uSD rebalance timeWindows : time windows inside which some time-delimited operations can be performed mintables : max amount of mintables inside a timeWindow","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-allowedpairs","text":"allowedPairs() \u2192 address[]","title":"Function: allowedPairs"},{"location":"stableCoin/standalone/IStableCoin/#return-values","text":"Array of allowed Uniswap pairs","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-availabletomint","text":"availableToMint() \u2192 uint256 mintable","title":"Function: availableToMint"},{"location":"stableCoin/standalone/IStableCoin/#return-values_1","text":"mintable The amount of available mintable token","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-differences","text":"differences() \u2192 uint256, uint256","title":"Function: differences"},{"location":"stableCoin/standalone/IStableCoin/#function-doubleproxy","text":"doubleProxy() \u2192 address","title":"Function: doubleProxy"},{"location":"stableCoin/standalone/IStableCoin/#return-values_2","text":"The address for the doubleProxy smart contract","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancerewardmultiplier","text":"rebalanceRewardMultiplier() \u2192 uint256[]","title":"Function: rebalanceRewardMultiplier"},{"location":"stableCoin/standalone/IStableCoin/#return-values_3","text":"The multiplier used to compute the rebalancing rewards","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-tierdata","text":"tierData() \u2192 uint256[], uint256[]","title":"Function: tierData"},{"location":"stableCoin/standalone/IStableCoin/#return-values_4","text":"All tiers of data of the carried context","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-setallowedpairs","text":"setAllowedPairs(address[] newAllowedPairs)","title":"Function: setAllowedPairs"},{"location":"stableCoin/standalone/IStableCoin/#parameters_1","text":"newAllowedPairs : list of Uniswap pairs to be whitelisted","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-setdoubleproxy","text":"setDoubleProxy(address newDoubleProxy)","title":"Function: setDoubleProxy"},{"location":"stableCoin/standalone/IStableCoin/#parameters_2","text":"newDoubleProxy : new DoubleProxy to set","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-calculaterebalancebydebtreward","text":"calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward","title":"Function: calculateRebalanceByDebtReward"},{"location":"stableCoin/standalone/IStableCoin/#description_1","text":"Compute the reward of the rebalanceByDebt() operation.","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_3","text":"burnt : amount of of uSD burnt","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-fromtokentostable","text":"fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256","title":"Function: fromTokenToStable"},{"location":"stableCoin/standalone/IStableCoin/#description_2","text":"Convert from one of the allowed whitelisted tokens to uSD","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_4","text":"tokenAddress : Address of the token to convert amount : Amount of Unifi token to be converted","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_5","text":"Amount of uSD tokens","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-mint","text":"mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256","title":"Function: mint"},{"location":"stableCoin/standalone/IStableCoin/#description_3","text":"Mint the uSD token","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_5","text":"pairIndex : Index of the pair inside the allowedPairs array amountA : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates) amountB : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates) amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_6","text":"Amount of freshly minted uSD token","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-burn","text":"burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 amountA, uint256 amountB","title":"Function: burn"},{"location":"stableCoin/standalone/IStableCoin/#description_4","text":"Mint the uSD token","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_6","text":"pairIndex : Index of the pair inside the allowedPairs array amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_7","text":"amountA The amount of tokenA received amountB The amount of tokenB received","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancebycredit","text":"rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed","title":"Function: rebalanceByCredit"},{"location":"stableCoin/standalone/IStableCoin/#description_5","text":"Rebalance by Credit is triggered when the total amount of source tokens' value is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancebydebt","text":"rebalanceByDebt(uint256 amount) \u2192 uint256","title":"Function: rebalanceByDebt"},{"location":"stableCoin/standalone/IStableCoin/#description_6","text":"Rebalance by Credit is triggered when the total amount of source tokens' value is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"Description"},{"location":"stableCoin/standalone/IStateHolder/","text":"IStateHolder Functions: getBool(string varName) getUint256(string varName) Function: getBool getBool(string varName) \u2192 bool Function: getUint256 getUint256(string varName) \u2192 uint256","title":"IStateHolder"},{"location":"stableCoin/standalone/IStateHolder/#istateholder","text":"","title":"IStateHolder"},{"location":"stableCoin/standalone/IStateHolder/#functions","text":"getBool(string varName) getUint256(string varName)","title":"Functions:"},{"location":"stableCoin/standalone/IStateHolder/#function-getbool","text":"getBool(string varName) \u2192 bool","title":"Function: getBool"},{"location":"stableCoin/standalone/IStateHolder/#function-getuint256","text":"getUint256(string varName) \u2192 uint256","title":"Function: getUint256"},{"location":"stableCoin/standalone/IUniswapV2Pair/","text":"IUniswapV2Pair Functions: decimals() totalSupply() token0() token1() balanceOf(address account) getReserves() Function: decimals decimals() \u2192 uint8 Function: totalSupply totalSupply() \u2192 uint256 Function: token0 token0() \u2192 address Function: token1 token1() \u2192 address Function: balanceOf balanceOf(address account) \u2192 uint256 Function: getReserves getReserves() \u2192 uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast","title":"IUniswapV2Pair"},{"location":"stableCoin/standalone/IUniswapV2Pair/#iuniswapv2pair","text":"","title":"IUniswapV2Pair"},{"location":"stableCoin/standalone/IUniswapV2Pair/#functions","text":"decimals() totalSupply() token0() token1() balanceOf(address account) getReserves()","title":"Functions:"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-decimals","text":"decimals() \u2192 uint8","title":"Function: decimals"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-token0","text":"token0() \u2192 address","title":"Function: token0"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-token1","text":"token1() \u2192 address","title":"Function: token1"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-getreserves","text":"getReserves() \u2192 uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast","title":"Function: getReserves"},{"location":"stableCoin/standalone/IUniswapV2Router/","text":"IUniswapV2Router Route liquidity back and forth an Uniswap Liquidity Pool. For more information see: https://uniswap.org/docs/v2/smart-contracts/router02/ Functions: getAmountsOut(uint256 amountIn, address[] path) removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) Function: getAmountsOut getAmountsOut(uint256 amountIn, address[] path) \u2192 uint256[] amounts Function: removeLiquidity removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB Description Removes liquidity from an ERC-20\u21c4ERC-20 pool https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity ===== Parameters: tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert to : Recipient of the underlying assets - deadline : Unix timestamp after which the transaction will revert Return Values: amountA The amount of tokenA received amountB The amount of tokenB received Function: addLiquidity addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB, uint256 liquidity Description Add Liquidity to an ERC-20\u21c4ERC-20 pool - To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB. - Always adds assets at the ideal ratio, according to the price when the transaction is executed. - If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added. https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity ===== Parameters: tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountADesired : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates). amountBDesired : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates). amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired. amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired. to : Recipient of the underlying assets - deadline : Unix timestamp after which the transaction will revert Return Values: amountA The amount of tokenA sent to the pool amountB The amount of tokenB sent to the pool liquidity The amount of liquidity tokens minted","title":"IUniswapV2Router"},{"location":"stableCoin/standalone/IUniswapV2Router/#iuniswapv2router","text":"Route liquidity back and forth an Uniswap Liquidity Pool. For more information see: https://uniswap.org/docs/v2/smart-contracts/router02/","title":"IUniswapV2Router"},{"location":"stableCoin/standalone/IUniswapV2Router/#functions","text":"getAmountsOut(uint256 amountIn, address[] path) removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline)","title":"Functions:"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-getamountsout","text":"getAmountsOut(uint256 amountIn, address[] path) \u2192 uint256[] amounts","title":"Function: getAmountsOut"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-removeliquidity","text":"removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB","title":"Function: removeLiquidity"},{"location":"stableCoin/standalone/IUniswapV2Router/#description","text":"Removes liquidity from an ERC-20\u21c4ERC-20 pool https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity =====","title":"Description"},{"location":"stableCoin/standalone/IUniswapV2Router/#parameters","text":"tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert to : Recipient of the underlying assets","title":"Parameters:"},{"location":"stableCoin/standalone/IUniswapV2Router/#-deadline-unix-timestamp-after-which-the-transaction-will-revert","text":"","title":"- deadline: Unix timestamp after which the transaction will revert"},{"location":"stableCoin/standalone/IUniswapV2Router/#return-values","text":"amountA The amount of tokenA received amountB The amount of tokenB received","title":"Return Values:"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-addliquidity","text":"addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB, uint256 liquidity","title":"Function: addLiquidity"},{"location":"stableCoin/standalone/IUniswapV2Router/#description_1","text":"Add Liquidity to an ERC-20\u21c4ERC-20 pool - To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB. - Always adds assets at the ideal ratio, according to the price when the transaction is executed. - If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added. https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity =====","title":"Description"},{"location":"stableCoin/standalone/IUniswapV2Router/#parameters_1","text":"tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountADesired : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates). amountBDesired : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates). amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired. amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired. to : Recipient of the underlying assets","title":"Parameters:"},{"location":"stableCoin/standalone/IUniswapV2Router/#-deadline-unix-timestamp-after-which-the-transaction-will-revert_1","text":"","title":"- deadline: Unix timestamp after which the transaction will revert"},{"location":"stableCoin/standalone/IUniswapV2Router/#return-values_1","text":"amountA The amount of tokenA sent to the pool amountB The amount of tokenB sent to the pool liquidity The amount of liquidity tokens minted","title":"Return Values:"},{"location":"stableCoin/standalone/SafeMath/","text":"SafeMath Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. SafeMath restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always. Functions:","title":"SafeMath"},{"location":"stableCoin/standalone/SafeMath/#safemath","text":"Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. SafeMath restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.","title":"SafeMath"},{"location":"stableCoin/standalone/SafeMath/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/StableCoin/","text":"StableCoin Contract for the \"uSD\" Stable Coin. It's an ERC20 token extended with the IStableCoin interface and DFO protocol magic. Functions: constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount) Function: constructor constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Description Contract constructor. See StableCoin.init() docs. Function: init init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Function: allowedPairs allowedPairs() \u2192 address[] Function: availableToMint availableToMint() \u2192 uint256 Function: differences differences() \u2192 uint256 credit, uint256 debt Function: doubleProxy doubleProxy() \u2192 address Function: rebalanceRewardMultiplier rebalanceRewardMultiplier() \u2192 uint256[] Function: tierData tierData() \u2192 uint256[], uint256[] Function: setAllowedPairs setAllowedPairs(address[] newAllowedPairs) Function: setDoubleProxy setDoubleProxy(address newDoubleProxy) Function: calculateRebalanceByDebtReward calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward Function: fromTokenToStable fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256 Function: mint mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 minted Description Minting first check tha DFO auth protocol are respected, secondly it sends the tokens to a Uniswap Pool (_createPoolToken) Function: burn burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 removedA, uint256 removedB Function: rebalanceByCredit rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed Description Rebalance by Credit is triggered when the total amount of source tokens is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool. Function: rebalanceByDebt rebalanceByDebt(uint256 amount) \u2192 uint256 reward","title":"StableCoin"},{"location":"stableCoin/standalone/StableCoin/#stablecoin","text":"Contract for the \"uSD\" Stable Coin. It's an ERC20 token extended with the IStableCoin interface and DFO protocol magic.","title":"StableCoin"},{"location":"stableCoin/standalone/StableCoin/#functions","text":"constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/StableCoin/#function-constructor","text":"constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: constructor"},{"location":"stableCoin/standalone/StableCoin/#description","text":"Contract constructor. See StableCoin.init() docs.","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-init","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: init"},{"location":"stableCoin/standalone/StableCoin/#function-allowedpairs","text":"allowedPairs() \u2192 address[]","title":"Function: allowedPairs"},{"location":"stableCoin/standalone/StableCoin/#function-availabletomint","text":"availableToMint() \u2192 uint256","title":"Function: availableToMint"},{"location":"stableCoin/standalone/StableCoin/#function-differences","text":"differences() \u2192 uint256 credit, uint256 debt","title":"Function: differences"},{"location":"stableCoin/standalone/StableCoin/#function-doubleproxy","text":"doubleProxy() \u2192 address","title":"Function: doubleProxy"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancerewardmultiplier","text":"rebalanceRewardMultiplier() \u2192 uint256[]","title":"Function: rebalanceRewardMultiplier"},{"location":"stableCoin/standalone/StableCoin/#function-tierdata","text":"tierData() \u2192 uint256[], uint256[]","title":"Function: tierData"},{"location":"stableCoin/standalone/StableCoin/#function-setallowedpairs","text":"setAllowedPairs(address[] newAllowedPairs)","title":"Function: setAllowedPairs"},{"location":"stableCoin/standalone/StableCoin/#function-setdoubleproxy","text":"setDoubleProxy(address newDoubleProxy)","title":"Function: setDoubleProxy"},{"location":"stableCoin/standalone/StableCoin/#function-calculaterebalancebydebtreward","text":"calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward","title":"Function: calculateRebalanceByDebtReward"},{"location":"stableCoin/standalone/StableCoin/#function-fromtokentostable","text":"fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256","title":"Function: fromTokenToStable"},{"location":"stableCoin/standalone/StableCoin/#function-mint","text":"mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 minted","title":"Function: mint"},{"location":"stableCoin/standalone/StableCoin/#description_1","text":"Minting first check tha DFO auth protocol are respected, secondly it sends the tokens to a Uniswap Pool (_createPoolToken)","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-burn","text":"burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 removedA, uint256 removedB","title":"Function: burn"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancebycredit","text":"rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed","title":"Function: rebalanceByCredit"},{"location":"stableCoin/standalone/StableCoin/#description_2","text":"Rebalance by Credit is triggered when the total amount of source tokens is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancebydebt","text":"rebalanceByDebt(uint256 amount) \u2192 uint256 reward","title":"Function: rebalanceByDebt"}]}