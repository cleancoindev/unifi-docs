{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"unifi Table of Contents Table of Contents Decentralized Finance on top of Uniswap, doing fantastic things securely Website: https://unifihub.com Unified Stable Dollar Example: Example: Rebalancing DFO Debit DFO Credit UniFi has a number of measures in place to ensure uSD's security. Resilience, Decentralization and Independence Allowed Stable Coins APIs and Documentation Responsible DeFi Limits Craft and Initial Liquidity Offerings (ILOs) How Does It Work? Programmable Liquidity Rules Let's play out that aforementioned example. Initial Liquidity Offering (ILO) Securing Initial Liquidity for AMMs With Fixed Inflation/Liquidity Staking Disarming Sniper Bots Securing Long Term Locked Investors How ILOs work: Example UniFi DFO Tax Releases The Bazar Listing Index Funds Programmable Equities Non-Fungible Tokens (NFTs) Swappable ERC 1155 Release UniFi Token Distribution UniFi Fair Inflation UniFi Liquidity Staking UniFi Earning System Decentralized Finance on top of Uniswap, doing fantastic things securely UniFi is a new Decentralized Flexible Organization (DFO) that researches and develops a responsible Decentralized Finance layer on top of Uniswap. A DFO protocol powered DeFi set of tools built on top of Uniswap Website: https://unifihub.com Unified Stable Dollar uSD is a stablecoin based on Uniswap Liquidity Pools Minted by the magic rainbow of Uniswap stablecoin pools, and backed by the power of the Unicorn, uSD is the most secure and resilient stablecoin on Ethereum\u200a-\u200aever. The only way it could be destabilized is if the entire stablecoin industry crashed. Independent from any off-chain issuer, it is fortified against every risk inherent to all other stablecoins, and free of the anxiety that pervades the industry. The protocol achieves this unprecedented feat by collateralizing other stablecoins. If any of them lose value or fail, it can simply rebalance itself to leverage the security of the others. And to account for excess due to fees earned by their pools, it can rebalance itself in another way. The only way uSD can be destabilized is if the entire stablecoin industry collapses. uSD is backed by a selection of Uniswap's (whitelisted) stablecoin liquidity pools.Anyone can mint it by adding these stablecoins to those pools. Example: Mint 2x uSD by adding 1x Stablecoin A and 1x Stablecoin B And by burning uSD, anyone can receive these stablecoins from those pools. Example: Burn 2x uSD and receive 1x Stablecoin A and 1x Stablecoin C Rebalancing Sometimes, collateralization is not enough, and uSD must rebalance in one of two ways. DFO Debit When a stablecoin loses value, the Uniswap Tier pools rebalance to an uneven disparity (\u2260 50/50). If the stablecoin totally fails, the other stablecoins effectively pump in correlation.DFO Debit resolves this issue on-chain by rebalancing uSD, creating debt which the UniFi DFO then pays off by minting UniFi. Let\u2019s look at how this plays out, step by step: 1 - A stablecoin collateralized by uSD loses value or fails altogether. 2 - $UniFi holders vote to remove the tiers containing the failed stablecoin from the whitelist.The uSD supply becomes grater than the supply of the collateralized pooled stablecoins. 3 - To restore 1:1 equilibrium, anyone holding uSD can burn it to receive new UniFi, minted at a 20% discount of the uSD/UniFi Uniswap pool mid-price ratio. The goal of $UniFi holders, which aligns with their self-interest, is to ensure uSD\u2019s security. Thus there is an economic disincentive to whitelist insecure stablecoins. DFO Credit As established, uSD is backed by Uniswap stablecoin pools liquidity. This raises an issue; Uniswap pools earn 0.3% of trading fees. This could destabilize uSD by creating an excess of collateralized stablecoins in the pools.DFO Credit, the second rebalancing function of the UniFi DFO, resolves this by removing that excess from the pools and sending it in the DFO wallet managed by $UniFi holders. This is a long term economic incentive for the UniFi DFO to grow and invest credit in R&D. UniFi has a number of measures in place to ensure uSD's security. uSD pool collateral is locked. Stored in an external smart contract, it can't be touched even by the UniFi DFO, precluding voter fraud by bad actors. In the case of any bug or update, $UniFi holders can vote to pause the uSD smart contract. This prevents minting of new uSD or rebalancing of uSD, but holders will still be able to redeem it for the pooled stable coins, and thus revoke the collateral. Even if the uSD protocol fails, and even if the UniFi DFO votes to update uSD to an undesirable new version, uSD holders will still be able to interact with the old smart contract\u200a-\u200auntil all collateral is revoked\u200a-\u200aas well as the new one. Resilience, Decentralization and Independence uSD is indeed the most resilient and secure stablecoin in the industry. By taking advantage to use Decentralized Finance on the top of Uniswap, a security layer with a decentralized core, it frees holders from dependence on censorship or centralized manipulation by states and stablecoin issuers, and resolves all risks that come with trusting the big stablecoin companies, like MakerDAO, Coinbase, etc. It is backed by a Decentralized Flexible Organization. $UniFi holders on the Ethereum network have 100% control of the code and Credit/Debit of the protocol. Nobody can stop or censor the UniFi-uSD protocol; for the first time, the Ethereum network doesn't have to choose between stability and independence in a stablecoin; it can have both. Allowed Stable Coins The allowed stablecoins to mint and burn uSD with are: DAI 0x6b175474e89094c44da98b954eedeac495271d0f USDC 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 GSDC 0x056fd409e1d7a124bd7017459dfea2f387b6d5cd BUSD 0x4fabb145d64652a948d72533023f6e7a623c7c53 TUSD 0x0000000000085d4780b73119b644ae5ecd22b376 PAX 0x8e870d67f660d95d5be530380d0ec0bd388289e1 APIs and Documentation To build on top of uSD and to interact with the dApp, you can find all of the documentation and APIs here: Documentation Responsible DeFi Limits Because we take a Responsible DeFi Approach, UniFi uSD minting is limited in its early stages: 500,000 uSD mintable for the first month (until block n 10941929) 2,000,000 uSD mintable for the first two months (until block n 11141929) 5,000,000 uSD mintable for the first three months (until block n 11341929) 10,000,000 uSD mintable for the first four months (until block n 11541929) 20,000,000 uSD mintable for the first five months (until block n 11741929) Craft and Initial Liquidity Offerings (ILOs) Craft makes it possible to provide liquidity that is programmable with advanced rules. Using Unicorn magic, pools can balance tokens diversely, and with unprecedented security. Programmable liquidity is an exciting new feature in AMMs (Automated Market Makers). However, if not applied correctly, it can actually be a security hole for bugs, due to math complexities (as we saw with Balancer recently). UniFi Crafting resolves this by offering programmable liquidity, but with the Uniswap protocol as a base layer, taking advantage of its secure and decentralized core. This also helps liquidity providers customize their investments, and empowers new applications on top of Uniswap. How Does It Work? The Uniswap protocol allows for liquidity pools composed of 50:50 asset ratios. This is usually the most secure setup for an AMM, but disincentivizes liquidity provision by incurring impermanent losses. Crafting resolves this, and opens up novel financial use cases for Uniswap pools. It is a fancy new way to build liquidity together, without needing to trust and know each other. Anyone can create a Craft order, customize the liquidity setup and deploy it by contributing initial liquidity. Others can then contribute the rest of the liquidity required to pool the order on Uniswap. Later, after the predetermined block, any of the participants can trigger removal of the liquidity. It is then distributed to all participants based on the predetermined rules. Programmable Liquidity Rules With Crafting, Uniswap liquidity providers can program a liquidity order by customizing the following: Tier: The Uniswap tier to which the liquidity will be added Waiting Length: The max time (in blocks) the order can remain available while the required liquidity is waiting to be filled. Min Block Length: The time (in blocks) for which the liquidity will be locked. If 0, any participant can trigger the removal of liquidity anytime. Liquidity Ratio: The ratio of liquidity, e.g. 10% DAI\u200a-\u200a90% ETH or 0% DAI\u200a-\u200a100 ETH. Once deployed by the creator, others can add the required liquidity. If the creator sets the ratio at 10% DAI\u200a-\u200a90% ETH, the others can add the rest at 90% DAI\u200a-\u200a10% ETH. Liquidity Exit/Discount: An advanced feature for orders that allows for the creation of a different ratio or even a discount for the exit. Let's play out that aforementioned example. Person A creates an order for USDC\u200a-\u200aDAI, with a min block length of 543055 Blocks and a ratio of 10% DAI\u200a-\u200a90% USDC. He adds 100 DAI and 900 USDC, and also decides to set the exit liquidity at 30% DAI and 70% USDC (read on to see exactly how exit liquidity works). B fills part of the remaining required liquidity (at a ratio of 90% DAI and 10% USDC) with 500 DAI and 50 USDC. C fills part of the remaining required liquidity (at a ratio of 90% DAI and 10% USDC) with 100 DAI and 10 USDC. D fills the rest of the required liquidity (at a ratio of 90% DAI and 10% USDC) with 300 DAI and 30 USDC. By adding the final remaining required liquidity, D has triggered Uniswap's Add Liquidity order \u2026 The total Uniswap liquidity pooled by A,B,C and D is 1,000 DAI and 1,000 USDC. After 543055 blocks, the liquidity pool has earned 1,000 USDC and 1,000 DAI in Uniswap trading fees, bringing the total to 2,000 DAI and 2,000 USDC. \u2026 B then triggers the removal action, and based on the fixed predetermined rules, the providers receive the following: A receives 600 DAI and 1,400 USDC (at the Exit Ratio of 30% DAI and 70% USDC). Based on how much they individually contributed, B, C and D receive their respective proportion of 1,400 DAI and 600 USDC (at the Exit Ratio of 70% DAI and 30% USDC). Initial Liquidity Offering (ILO) ILOs are a way for Ethereum-based startups to configure \"Crafting\"\u200a-\u200ai.e, Programmable Liquidity\u200a-\u200arules to secure long term funding by providing Uniswap liquidity. ILOs are helpful for three specific reasons: Securing Initial Liquidity for AMMs With Fixed Inflation/Liquidity Staking Providers can offer liquidity with fixed inflation without dumping on new holders. They also help new investors reduce slippage and become holders with a large amount of capital. Disarming Sniper Bots Sniper Bots track new low liquidity Uniswap pools for sizable capital before liquidity even comes in, making it (until now) impossible for startups to offer liquidity with low collateral. Securing Long Term Locked Investors Investors lock their funds for the long run. How ILOs work: Before distributing their tokens, startups can set crafting orders with fixed pre-values, adding the token and requesting the collateral required to fill the order. Investors provide that collateral, and if the startup chooses, investors get an Exit/Discount to mitigate the high risk. Example The token creator sets a Crafting order with low liquidity, e.g. 1,000,000 of the token and 1 ETH, with a 90%\u200a-\u200a10% ratio, or even 1,000,000 of token and 0 ETH, with a 100%\u200a-\u200a0% ratio (adding a pre-value of the token, if the liquidity pool is not open yet) for one year. Setting the Liquidity Exit/Discount 10%/20%, investors will receive at the end of the order 90%/80%. In this case, investors invest their own Ethereum for a new token that is not already tradable. This entails a high level or risk, and so they are compensated by receiving a more significant portion of the liquidity at the end of the year; in this case, from 50% added to 170% received. ILOs enable new Ethereum fundraising rules that solve liquidity issues in early stages, while also helping legitimate projects set Fixed Inflation. This empowers projects and investors in the long run.UniFi DFO Tax: UniFi DFO Tax The UniFi DFO earns via the Crafting function; 0.1% of the total Uniswap pool tokens in a Craft order is taxed and paid directly when a participant calls the remove function. Releases The release Of Crafting and ILOs is expected for early October 2020. The Bazar Ancient black magic is unleashing the true power of the Unicorn. Programmable Equities and Token Index Funds (and soon NFTs, including ERC1155s, thanks to ethArt V2) can now be swapped on the new Bazar DEX. The UniFi Bazar unleashes the true potential of Decentralized Finance on the top of Uniswap, by enabling Ethereans to trade these more easily than ever before. Listing Index Funds Previously, any ERC20 Uniswap V2 pool token could be traded on Uniswap. But Index Funds\u200a-\u200abacked by multiple ERC20 tokens\u200a-\u200acould not. Until now. On the Bazar, Ethereans can freely swap and track crypto Index Funds. Programmable Equities Programmable equities are a new asset class in crypto. They are the ERC20 voting tokens of Decentralized Flexible Organizations (DFOs). Holders have 100% ownership of the protocol; there is no opportunity for external manipulation. On the Bazar, all programmable equities can be listed and traded on Uniswap. Non-Fungible Tokens (NFTs) ERC1155 NFTs are tokens with metadata, but at the same time have a supply. The reason they haven't been tradable in AMMs before is due to their 'transfer' function. They use the 'SafeTransferFrom' method, instead of the ERC20 methods, 'Transfer' and 'TransferFrom.' Also, they don't have decimals; they're transferred using ID and Amount. ethArt V2 will be released in November, and the Bazar will be able to synthesise ERC1155 tokens with ERC20s (as WETH with ETH) in the background, fundamentally reshaping the NFT market by allowing Ethereans to trade ERC1155 tokens for the first time. Swappable ERC 1155 Release The release of ethArt V2 and swappable NFTs is scheduled for late November. UniFi Token Distribution The total supply of $UniFi is 88,888,888, which is initially distributed and Locked as follows: 36% (32,042,000) are locked in the NERV Wallet [0x25756f9C2cCeaCd787260b001F224159aB9fB97A] This is the DFOhub Operation' DFO wallet, funded by Fair Inflation. 40% (35,900,000) are locked in the UniFI's DFO wallet [0x2578aA454b29C15c8eEF62C972Ee1ff57CD99DEf] . This pays out the liquidity staking rewards. The active reward staking contract is [0xb266252Fd70D253b4330151A96694d35e94b846c] 16% (14,333,333) are locked in the DFOhub wallet (owned by $buidl holders) [0x5D40c724ba3e7Ffa6a91db223368977C522BdACD] UniFi Fair Inflation A sustainable economic model for DFO-based startups to maintain value and fund operations | UniFi version The original whitepaper of the first fair inflation mechanism was for buidl ( (https://github.com/b-u-i-d-l/fair-inflation-v2) ) UniFi's fair inflation will inflate the supply by 2% (1,788,500 $UniFi) over the first year via NERV (The DFOhub Team Operations' DFO) Inflation events will occur once a day (every 6,300 ETH Blocks) across three Uniswap pairs, for a total of 4,900 $UniFi each event: Uniswap V2 $ETH/$UniFi (2695 $UniFi every day)\u200a-\u200a55% Uniswap V2 $USDC/$UniFi (1470 $UniFi every day)\u200a-\u200a30% Uniswap V2 $BUIDL/$UniFi (735 $UniFi every day)\u200a-\u200a15% All functionalities related to this R&D will become available for every DFO as Optional Basic Functionalities, to accelerate the exploration of Programmable Equity R&D. UniFi Liquidity Staking $UniFi liquidity staking is available here: https://dapp.dfohub.com/?staking=0xb266252Fd70D253b4330151A96694d35e94b846c The UniFi Liquidity Staking Mechanism is designed to reward those who lock up Uniswap V2 liquidity for the long term. Staking will inflate the supply over the first year (if every tier is completely filled) by 918,000 $UniFi (1% of the supply). The Five Year tier was filled by the team in an early test, and we won't touch the rewards for three years. When they are unlocked and redeemed, 50% of the UniFi will be sent to the UniFi wallet and 50% to the NERV operations wallet. UniFi Earning System The UniFi DFO earn from: The uSD positive rebalance (the trading fees of Uniswap collateralized stablecoins) The 0.1% in Uniswap Pool Tokens taxed by crafting Programmable Liquidity As an on-chain company, UniFi's value will be backed by these earnings, and by the core of Flexible Organizations, totally ruled in code and assets by tokens, without any chance of external manipulation.","title":"Home"},{"location":"#unifi","text":"","title":"unifi"},{"location":"#table-of-contents","text":"Table of Contents Decentralized Finance on top of Uniswap, doing fantastic things securely Website: https://unifihub.com Unified Stable Dollar Example: Example: Rebalancing DFO Debit DFO Credit UniFi has a number of measures in place to ensure uSD's security. Resilience, Decentralization and Independence Allowed Stable Coins APIs and Documentation Responsible DeFi Limits Craft and Initial Liquidity Offerings (ILOs) How Does It Work? Programmable Liquidity Rules Let's play out that aforementioned example. Initial Liquidity Offering (ILO) Securing Initial Liquidity for AMMs With Fixed Inflation/Liquidity Staking Disarming Sniper Bots Securing Long Term Locked Investors How ILOs work: Example UniFi DFO Tax Releases The Bazar Listing Index Funds Programmable Equities Non-Fungible Tokens (NFTs) Swappable ERC 1155 Release UniFi Token Distribution UniFi Fair Inflation UniFi Liquidity Staking UniFi Earning System","title":"Table of Contents"},{"location":"#decentralized-finance-on-top-of-uniswap-doing-fantastic-things-securely","text":"UniFi is a new Decentralized Flexible Organization (DFO) that researches and develops a responsible Decentralized Finance layer on top of Uniswap. A DFO protocol powered DeFi set of tools built on top of Uniswap","title":"Decentralized Finance on top of Uniswap, doing fantastic things\u00a0securely"},{"location":"#website-httpsunifihubcom","text":"","title":"Website: https://unifihub.com"},{"location":"#unified-stable-dollar","text":"uSD is a stablecoin based on Uniswap Liquidity Pools Minted by the magic rainbow of Uniswap stablecoin pools, and backed by the power of the Unicorn, uSD is the most secure and resilient stablecoin on Ethereum\u200a-\u200aever. The only way it could be destabilized is if the entire stablecoin industry crashed. Independent from any off-chain issuer, it is fortified against every risk inherent to all other stablecoins, and free of the anxiety that pervades the industry. The protocol achieves this unprecedented feat by collateralizing other stablecoins. If any of them lose value or fail, it can simply rebalance itself to leverage the security of the others. And to account for excess due to fees earned by their pools, it can rebalance itself in another way. The only way uSD can be destabilized is if the entire stablecoin industry collapses. uSD is backed by a selection of Uniswap's (whitelisted) stablecoin liquidity pools.Anyone can mint it by adding these stablecoins to those pools.","title":"Unified Stable\u00a0Dollar"},{"location":"#example","text":"Mint 2x uSD by adding 1x Stablecoin A and 1x Stablecoin B And by burning uSD, anyone can receive these stablecoins from those pools.","title":"Example:"},{"location":"#example_1","text":"Burn 2x uSD and receive 1x Stablecoin A and 1x Stablecoin C","title":"Example:"},{"location":"#rebalancing","text":"Sometimes, collateralization is not enough, and uSD must rebalance in one of two ways.","title":"Rebalancing"},{"location":"#dfo-debit","text":"When a stablecoin loses value, the Uniswap Tier pools rebalance to an uneven disparity (\u2260 50/50). If the stablecoin totally fails, the other stablecoins effectively pump in correlation.DFO Debit resolves this issue on-chain by rebalancing uSD, creating debt which the UniFi DFO then pays off by minting UniFi. Let\u2019s look at how this plays out, step by step: 1 - A stablecoin collateralized by uSD loses value or fails altogether. 2 - $UniFi holders vote to remove the tiers containing the failed stablecoin from the whitelist.The uSD supply becomes grater than the supply of the collateralized pooled stablecoins. 3 - To restore 1:1 equilibrium, anyone holding uSD can burn it to receive new UniFi, minted at a 20% discount of the uSD/UniFi Uniswap pool mid-price ratio. The goal of $UniFi holders, which aligns with their self-interest, is to ensure uSD\u2019s security. Thus there is an economic disincentive to whitelist insecure stablecoins.","title":"DFO Debit"},{"location":"#dfo-credit","text":"As established, uSD is backed by Uniswap stablecoin pools liquidity. This raises an issue; Uniswap pools earn 0.3% of trading fees. This could destabilize uSD by creating an excess of collateralized stablecoins in the pools.DFO Credit, the second rebalancing function of the UniFi DFO, resolves this by removing that excess from the pools and sending it in the DFO wallet managed by $UniFi holders. This is a long term economic incentive for the UniFi DFO to grow and invest credit in R&D.","title":"DFO Credit"},{"location":"#unifi-has-a-number-of-measures-in-place-to-ensure-usds-security","text":"uSD pool collateral is locked. Stored in an external smart contract, it can't be touched even by the UniFi DFO, precluding voter fraud by bad actors. In the case of any bug or update, $UniFi holders can vote to pause the uSD smart contract. This prevents minting of new uSD or rebalancing of uSD, but holders will still be able to redeem it for the pooled stable coins, and thus revoke the collateral. Even if the uSD protocol fails, and even if the UniFi DFO votes to update uSD to an undesirable new version, uSD holders will still be able to interact with the old smart contract\u200a-\u200auntil all collateral is revoked\u200a-\u200aas well as the new one.","title":"UniFi has a number of measures in place to ensure uSD's security."},{"location":"#resilience-decentralization-and-independence","text":"uSD is indeed the most resilient and secure stablecoin in the industry. By taking advantage to use Decentralized Finance on the top of Uniswap, a security layer with a decentralized core, it frees holders from dependence on censorship or centralized manipulation by states and stablecoin issuers, and resolves all risks that come with trusting the big stablecoin companies, like MakerDAO, Coinbase, etc. It is backed by a Decentralized Flexible Organization. $UniFi holders on the Ethereum network have 100% control of the code and Credit/Debit of the protocol. Nobody can stop or censor the UniFi-uSD protocol; for the first time, the Ethereum network doesn't have to choose between stability and independence in a stablecoin; it can have both.","title":"Resilience, Decentralization and Independence"},{"location":"#allowed-stable-coins","text":"The allowed stablecoins to mint and burn uSD with are: DAI 0x6b175474e89094c44da98b954eedeac495271d0f USDC 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 GSDC 0x056fd409e1d7a124bd7017459dfea2f387b6d5cd BUSD 0x4fabb145d64652a948d72533023f6e7a623c7c53 TUSD 0x0000000000085d4780b73119b644ae5ecd22b376 PAX 0x8e870d67f660d95d5be530380d0ec0bd388289e1","title":"Allowed Stable\u00a0Coins"},{"location":"#apis-and-documentation","text":"To build on top of uSD and to interact with the dApp, you can find all of the documentation and APIs here: Documentation","title":"APIs and Documentation"},{"location":"#responsible-defi-limits","text":"Because we take a Responsible DeFi Approach, UniFi uSD minting is limited in its early stages: 500,000 uSD mintable for the first month (until block n 10941929) 2,000,000 uSD mintable for the first two months (until block n 11141929) 5,000,000 uSD mintable for the first three months (until block n 11341929) 10,000,000 uSD mintable for the first four months (until block n 11541929) 20,000,000 uSD mintable for the first five months (until block n 11741929)","title":"Responsible DeFi\u00a0Limits"},{"location":"#craft-and-initial-liquidity-offerings-ilos","text":"Craft makes it possible to provide liquidity that is programmable with advanced rules. Using Unicorn magic, pools can balance tokens diversely, and with unprecedented security. Programmable liquidity is an exciting new feature in AMMs (Automated Market Makers). However, if not applied correctly, it can actually be a security hole for bugs, due to math complexities (as we saw with Balancer recently). UniFi Crafting resolves this by offering programmable liquidity, but with the Uniswap protocol as a base layer, taking advantage of its secure and decentralized core. This also helps liquidity providers customize their investments, and empowers new applications on top of Uniswap.","title":"Craft and Initial Liquidity Offerings (ILOs)"},{"location":"#how-does-it-work","text":"The Uniswap protocol allows for liquidity pools composed of 50:50 asset ratios. This is usually the most secure setup for an AMM, but disincentivizes liquidity provision by incurring impermanent losses. Crafting resolves this, and opens up novel financial use cases for Uniswap pools. It is a fancy new way to build liquidity together, without needing to trust and know each other. Anyone can create a Craft order, customize the liquidity setup and deploy it by contributing initial liquidity. Others can then contribute the rest of the liquidity required to pool the order on Uniswap. Later, after the predetermined block, any of the participants can trigger removal of the liquidity. It is then distributed to all participants based on the predetermined rules.","title":"How Does It Work?"},{"location":"#programmable-liquidity-rules","text":"With Crafting, Uniswap liquidity providers can program a liquidity order by customizing the following: Tier: The Uniswap tier to which the liquidity will be added Waiting Length: The max time (in blocks) the order can remain available while the required liquidity is waiting to be filled. Min Block Length: The time (in blocks) for which the liquidity will be locked. If 0, any participant can trigger the removal of liquidity anytime. Liquidity Ratio: The ratio of liquidity, e.g. 10% DAI\u200a-\u200a90% ETH or 0% DAI\u200a-\u200a100 ETH. Once deployed by the creator, others can add the required liquidity. If the creator sets the ratio at 10% DAI\u200a-\u200a90% ETH, the others can add the rest at 90% DAI\u200a-\u200a10% ETH. Liquidity Exit/Discount: An advanced feature for orders that allows for the creation of a different ratio or even a discount for the exit.","title":"Programmable Liquidity Rules"},{"location":"#lets-play-out-that-aforementioned-example","text":"Person A creates an order for USDC\u200a-\u200aDAI, with a min block length of 543055 Blocks and a ratio of 10% DAI\u200a-\u200a90% USDC. He adds 100 DAI and 900 USDC, and also decides to set the exit liquidity at 30% DAI and 70% USDC (read on to see exactly how exit liquidity works). B fills part of the remaining required liquidity (at a ratio of 90% DAI and 10% USDC) with 500 DAI and 50 USDC. C fills part of the remaining required liquidity (at a ratio of 90% DAI and 10% USDC) with 100 DAI and 10 USDC. D fills the rest of the required liquidity (at a ratio of 90% DAI and 10% USDC) with 300 DAI and 30 USDC. By adding the final remaining required liquidity, D has triggered Uniswap's Add Liquidity order \u2026 The total Uniswap liquidity pooled by A,B,C and D is 1,000 DAI and 1,000 USDC. After 543055 blocks, the liquidity pool has earned 1,000 USDC and 1,000 DAI in Uniswap trading fees, bringing the total to 2,000 DAI and 2,000 USDC. \u2026 B then triggers the removal action, and based on the fixed predetermined rules, the providers receive the following: A receives 600 DAI and 1,400 USDC (at the Exit Ratio of 30% DAI and 70% USDC). Based on how much they individually contributed, B, C and D receive their respective proportion of 1,400 DAI and 600 USDC (at the Exit Ratio of 70% DAI and 30% USDC).","title":"Let's play out that aforementioned example."},{"location":"#initial-liquidity-offering-ilo","text":"ILOs are a way for Ethereum-based startups to configure \"Crafting\"\u200a-\u200ai.e, Programmable Liquidity\u200a-\u200arules to secure long term funding by providing Uniswap liquidity. ILOs are helpful for three specific reasons:","title":"Initial Liquidity Offering\u00a0(ILO)"},{"location":"#securing-initial-liquidity-for-amms-with-fixed-inflationliquidity-staking","text":"Providers can offer liquidity with fixed inflation without dumping on new holders. They also help new investors reduce slippage and become holders with a large amount of capital.","title":"Securing Initial Liquidity for AMMs With Fixed Inflation/Liquidity Staking"},{"location":"#disarming-sniper-bots","text":"Sniper Bots track new low liquidity Uniswap pools for sizable capital before liquidity even comes in, making it (until now) impossible for startups to offer liquidity with low collateral.","title":"Disarming Sniper Bots"},{"location":"#securing-long-term-locked-investors","text":"Investors lock their funds for the long run.","title":"Securing Long Term Locked Investors"},{"location":"#how-ilos-work","text":"Before distributing their tokens, startups can set crafting orders with fixed pre-values, adding the token and requesting the collateral required to fill the order. Investors provide that collateral, and if the startup chooses, investors get an Exit/Discount to mitigate the high risk.","title":"How ILOs work:"},{"location":"#example_2","text":"The token creator sets a Crafting order with low liquidity, e.g. 1,000,000 of the token and 1 ETH, with a 90%\u200a-\u200a10% ratio, or even 1,000,000 of token and 0 ETH, with a 100%\u200a-\u200a0% ratio (adding a pre-value of the token, if the liquidity pool is not open yet) for one year. Setting the Liquidity Exit/Discount 10%/20%, investors will receive at the end of the order 90%/80%. In this case, investors invest their own Ethereum for a new token that is not already tradable. This entails a high level or risk, and so they are compensated by receiving a more significant portion of the liquidity at the end of the year; in this case, from 50% added to 170% received. ILOs enable new Ethereum fundraising rules that solve liquidity issues in early stages, while also helping legitimate projects set Fixed Inflation. This empowers projects and investors in the long run.UniFi DFO Tax:","title":"Example"},{"location":"#unifi-dfo-tax","text":"The UniFi DFO earns via the Crafting function; 0.1% of the total Uniswap pool tokens in a Craft order is taxed and paid directly when a participant calls the remove function.","title":"UniFi DFO Tax"},{"location":"#releases","text":"The release Of Crafting and ILOs is expected for early October 2020.","title":"Releases"},{"location":"#the-bazar","text":"Ancient black magic is unleashing the true power of the Unicorn. Programmable Equities and Token Index Funds (and soon NFTs, including ERC1155s, thanks to ethArt V2) can now be swapped on the new Bazar DEX. The UniFi Bazar unleashes the true potential of Decentralized Finance on the top of Uniswap, by enabling Ethereans to trade these more easily than ever before.","title":"The\u00a0Bazar"},{"location":"#listing","text":"","title":"Listing"},{"location":"#index-funds","text":"Previously, any ERC20 Uniswap V2 pool token could be traded on Uniswap. But Index Funds\u200a-\u200abacked by multiple ERC20 tokens\u200a-\u200acould not. Until now. On the Bazar, Ethereans can freely swap and track crypto Index Funds.","title":"Index Funds"},{"location":"#programmable-equities","text":"Programmable equities are a new asset class in crypto. They are the ERC20 voting tokens of Decentralized Flexible Organizations (DFOs). Holders have 100% ownership of the protocol; there is no opportunity for external manipulation. On the Bazar, all programmable equities can be listed and traded on Uniswap.","title":"Programmable Equities"},{"location":"#non-fungible-tokens-nfts","text":"ERC1155 NFTs are tokens with metadata, but at the same time have a supply. The reason they haven't been tradable in AMMs before is due to their 'transfer' function. They use the 'SafeTransferFrom' method, instead of the ERC20 methods, 'Transfer' and 'TransferFrom.' Also, they don't have decimals; they're transferred using ID and Amount. ethArt V2 will be released in November, and the Bazar will be able to synthesise ERC1155 tokens with ERC20s (as WETH with ETH) in the background, fundamentally reshaping the NFT market by allowing Ethereans to trade ERC1155 tokens for the first time.","title":"Non-Fungible Tokens (NFTs)"},{"location":"#swappable-erc-1155-release","text":"The release of ethArt V2 and swappable NFTs is scheduled for late November.","title":"Swappable ERC 1155 Release"},{"location":"#unifi-token-distribution","text":"The total supply of $UniFi is 88,888,888, which is initially distributed and Locked as follows: 36% (32,042,000) are locked in the NERV Wallet [0x25756f9C2cCeaCd787260b001F224159aB9fB97A] This is the DFOhub Operation' DFO wallet, funded by Fair Inflation. 40% (35,900,000) are locked in the UniFI's DFO wallet [0x2578aA454b29C15c8eEF62C972Ee1ff57CD99DEf] . This pays out the liquidity staking rewards. The active reward staking contract is [0xb266252Fd70D253b4330151A96694d35e94b846c] 16% (14,333,333) are locked in the DFOhub wallet (owned by $buidl holders) [0x5D40c724ba3e7Ffa6a91db223368977C522BdACD]","title":"UniFi Token Distribution"},{"location":"#unifi-fair-inflation","text":"A sustainable economic model for DFO-based startups to maintain value and fund operations | UniFi version The original whitepaper of the first fair inflation mechanism was for buidl ( (https://github.com/b-u-i-d-l/fair-inflation-v2) ) UniFi's fair inflation will inflate the supply by 2% (1,788,500 $UniFi) over the first year via NERV (The DFOhub Team Operations' DFO) Inflation events will occur once a day (every 6,300 ETH Blocks) across three Uniswap pairs, for a total of 4,900 $UniFi each event: Uniswap V2 $ETH/$UniFi (2695 $UniFi every day)\u200a-\u200a55% Uniswap V2 $USDC/$UniFi (1470 $UniFi every day)\u200a-\u200a30% Uniswap V2 $BUIDL/$UniFi (735 $UniFi every day)\u200a-\u200a15% All functionalities related to this R&D will become available for every DFO as Optional Basic Functionalities, to accelerate the exploration of Programmable Equity R&D.","title":"UniFi Fair Inflation"},{"location":"#unifi-liquidity-staking","text":"$UniFi liquidity staking is available here: https://dapp.dfohub.com/?staking=0xb266252Fd70D253b4330151A96694d35e94b846c The UniFi Liquidity Staking Mechanism is designed to reward those who lock up Uniswap V2 liquidity for the long term. Staking will inflate the supply over the first year (if every tier is completely filled) by 918,000 $UniFi (1% of the supply). The Five Year tier was filled by the team in an early test, and we won't touch the rewards for three years. When they are unlocked and redeemed, 50% of the UniFi will be sent to the UniFi wallet and 50% to the NERV operations wallet.","title":"UniFi Liquidity Staking"},{"location":"#unifi-earning-system","text":"The UniFi DFO earn from: The uSD positive rebalance (the trading fees of Uniswap collateralized stablecoins) The 0.1% in Uniswap Pool Tokens taxed by crafting Programmable Liquidity As an on-chain company, UniFi's value will be backed by these earnings, and by the core of Flexible Organizations, totally ruled in code and assets by tokens, without any chance of external manipulation.","title":"UniFi Earning\u00a0System"},{"location":"CONTRIBUTING/","text":"Contributing guidelines Table of Contents Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs Coding Style Solidity Solidity portions of the codebase adhere follow the official Solidity Styleguide JavaScript Python Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings. Documentation New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec and [Solidity Domain for Sphinx]. Documentation is generated using solidity-docgen and rendered via mkdocs . solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to an Handlebars template located at docs/solidity-docgen-templates/contract.hbs . NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve mkdocs To install mkdocs Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"","title":"Contributing guidelines"},{"location":"CONTRIBUTING/#table-of-contents","text":"Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs","title":"Table of Contents"},{"location":"CONTRIBUTING/#coding-style","text":"","title":"Coding Style"},{"location":"CONTRIBUTING/#solidity","text":"Solidity portions of the codebase adhere follow the official Solidity Styleguide","title":"Solidity"},{"location":"CONTRIBUTING/#javascript","text":"","title":"JavaScript"},{"location":"CONTRIBUTING/#python","text":"Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings.","title":"Python"},{"location":"CONTRIBUTING/#documentation","text":"New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec and [Solidity Domain for Sphinx]. Documentation is generated using solidity-docgen and rendered via mkdocs . solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to an Handlebars template located at docs/solidity-docgen-templates/contract.hbs . NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve","title":"Documentation"},{"location":"CONTRIBUTING/#mkdocs","text":"To install mkdocs Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"mkdocs"},{"location":"stableCoin/microservices/IERC20/","text":"IERC20 Functions: mint(uint256 amount) balanceOf(address account) Function: mint mint(uint256 amount) Function: balanceOf balanceOf(address account) \u2192 uint256","title":"IERC20"},{"location":"stableCoin/microservices/IERC20/#ierc20","text":"","title":"IERC20"},{"location":"stableCoin/microservices/IERC20/#functions","text":"mint(uint256 amount) balanceOf(address account)","title":"Functions:"},{"location":"stableCoin/microservices/IERC20/#function-mint","text":"mint(uint256 amount)","title":"Function: mint"},{"location":"stableCoin/microservices/IERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/","text":"IMVDFunctionalitiesManager Functions: isAuthorizedFunctionality(address functionality) Function: isAuthorizedFunctionality isAuthorizedFunctionality(address functionality) \u2192 bool","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#imvdfunctionalitiesmanager","text":"","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#functions","text":"isAuthorizedFunctionality(address functionality)","title":"Functions:"},{"location":"stableCoin/microservices/IMVDFunctionalitiesManager/#function-isauthorizedfunctionality","text":"isAuthorizedFunctionality(address functionality) \u2192 bool","title":"Function: isAuthorizedFunctionality"},{"location":"stableCoin/microservices/IMVDProxy/","text":"IMVDProxy Functions: getToken() getStateHolderAddress() getMVDFunctionalitiesManagerAddress() transfer(address receiver, uint256 value, address token) flushToWallet(address tokenAddress, bool is721, uint256 tokenId) Function: getToken getToken() \u2192 address Function: getStateHolderAddress getStateHolderAddress() \u2192 address Function: getMVDFunctionalitiesManagerAddress getMVDFunctionalitiesManagerAddress() \u2192 address Function: transfer transfer(address receiver, uint256 value, address token) Function: flushToWallet flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"IMVDProxy"},{"location":"stableCoin/microservices/IMVDProxy/#imvdproxy","text":"","title":"IMVDProxy"},{"location":"stableCoin/microservices/IMVDProxy/#functions","text":"getToken() getStateHolderAddress() getMVDFunctionalitiesManagerAddress() transfer(address receiver, uint256 value, address token) flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"Functions:"},{"location":"stableCoin/microservices/IMVDProxy/#function-gettoken","text":"getToken() \u2192 address","title":"Function: getToken"},{"location":"stableCoin/microservices/IMVDProxy/#function-getstateholderaddress","text":"getStateHolderAddress() \u2192 address","title":"Function: getStateHolderAddress"},{"location":"stableCoin/microservices/IMVDProxy/#function-getmvdfunctionalitiesmanageraddress","text":"getMVDFunctionalitiesManagerAddress() \u2192 address","title":"Function: getMVDFunctionalitiesManagerAddress"},{"location":"stableCoin/microservices/IMVDProxy/#function-transfer","text":"transfer(address receiver, uint256 value, address token)","title":"Function: transfer"},{"location":"stableCoin/microservices/IMVDProxy/#function-flushtowallet","text":"flushToWallet(address tokenAddress, bool is721, uint256 tokenId)","title":"Function: flushToWallet"},{"location":"stableCoin/microservices/IStateHolder/","text":"IStateHolder Functions: clear(string varName) setBool(string varName, bool val) getBool(string varName) Function: clear clear(string varName) \u2192 string oldDataType, bytes oldVal Function: setBool setBool(string varName, bool val) \u2192 bool Function: getBool getBool(string varName) \u2192 bool","title":"IStateHolder"},{"location":"stableCoin/microservices/IStateHolder/#istateholder","text":"","title":"IStateHolder"},{"location":"stableCoin/microservices/IStateHolder/#functions","text":"clear(string varName) setBool(string varName, bool val) getBool(string varName)","title":"Functions:"},{"location":"stableCoin/microservices/IStateHolder/#function-clear","text":"clear(string varName) \u2192 string oldDataType, bytes oldVal","title":"Function: clear"},{"location":"stableCoin/microservices/IStateHolder/#function-setbool","text":"setBool(string varName, bool val) \u2192 bool","title":"Function: setBool"},{"location":"stableCoin/microservices/IStateHolder/#function-getbool","text":"getBool(string varName) \u2192 bool","title":"Function: getBool"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/","text":"MintNewVotingTokensForStableCoinFunctionality This contract adds unifi minting capabilies to uSD Functions: onStart(address, address) onStop(address) mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver) Function: onStart onStart(address, address) Function: onStop onStop(address) Function: mintNewVotingTokensForStableCoin mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"MintNewVotingTokensForStableCoinFunctionality"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#mintnewvotingtokensforstablecoinfunctionality","text":"This contract adds unifi minting capabilies to uSD","title":"MintNewVotingTokensForStableCoinFunctionality"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#functions","text":"onStart(address, address) onStop(address) mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"Functions:"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-onstart","text":"onStart(address, address)","title":"Function: onStart"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-onstop","text":"onStop(address)","title":"Function: onStop"},{"location":"stableCoin/microservices/MintNewVotingTokensForStableCoinFunctionality/#function-mintnewvotingtokensforstablecoin","text":"mintNewVotingTokensForStableCoin(address sender, uint256, uint256 amountToMint, address receiver)","title":"Function: mintNewVotingTokensForStableCoin"},{"location":"stableCoin/standalone/Address/","text":"Address Collection of functions related to the address type Functions:","title":"Address"},{"location":"stableCoin/standalone/Address/#address","text":"Collection of functions related to the address type","title":"Address"},{"location":"stableCoin/standalone/Address/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/Context/","text":"Context Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with GSN meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts. Functions:","title":"Context"},{"location":"stableCoin/standalone/Context/#context","text":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with GSN meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","title":"Context"},{"location":"stableCoin/standalone/Context/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/ERC20/","text":"ERC20 Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning false on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}. Functions: name() symbol() decimals() totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) increaseAllowance(address spender, uint256 addedValue) decreaseAllowance(address spender, uint256 subtractedValue) Function: name name() \u2192 string Description Returns the name of the token. Function: symbol symbol() \u2192 string Description Returns the symbol of the token, usually a shorter version of the name. Function: decimals decimals() \u2192 uint8 Description Returns the number of decimals used to get its user representation. For example, if decimals equals 2 , a balance of 505 tokens should be displayed to a user as 5,05 ( 505 / 10 ** 2 ). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless { setupDecimals} is called. NOTE: This information is only used for _display purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}. Function: totalSupply totalSupply() \u2192 uint256 Description See {IERC20-totalSupply}. Function: balanceOf balanceOf(address account) \u2192 uint256 Description See {IERC20-balanceOf}. Function: transfer transfer(address recipient, uint256 amount) \u2192 bool Description See {IERC20-transfer}. Requirements: - recipient cannot be the zero address. - the caller must have a balance of at least amount . Function: allowance allowance(address owner, address spender) \u2192 uint256 Description See {IERC20-allowance}. Function: approve approve(address spender, uint256 amount) \u2192 bool Description See {IERC20-approve}. Requirements: - spender cannot be the zero address. Function: transferFrom transferFrom(address sender, address recipient, uint256 amount) \u2192 bool Description See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - sender and recipient cannot be the zero address. - sender must have a balance of at least amount . - the caller must have allowance for sender 's tokens of at least amount . Function: increaseAllowance increaseAllowance(address spender, uint256 addedValue) \u2192 bool Description Atomically increases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. Function: decreaseAllowance decreaseAllowance(address spender, uint256 subtractedValue) \u2192 bool Description Atomically decreases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. - spender must have allowance for the caller of at least subtractedValue .","title":"ERC20"},{"location":"stableCoin/standalone/ERC20/#erc20","text":"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning false on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.","title":"ERC20"},{"location":"stableCoin/standalone/ERC20/#functions","text":"name() symbol() decimals() totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) increaseAllowance(address spender, uint256 addedValue) decreaseAllowance(address spender, uint256 subtractedValue)","title":"Functions:"},{"location":"stableCoin/standalone/ERC20/#function-name","text":"name() \u2192 string","title":"Function: name"},{"location":"stableCoin/standalone/ERC20/#description","text":"Returns the name of the token.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-symbol","text":"symbol() \u2192 string","title":"Function: symbol"},{"location":"stableCoin/standalone/ERC20/#description_1","text":"Returns the symbol of the token, usually a shorter version of the name.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-decimals","text":"decimals() \u2192 uint8","title":"Function: decimals"},{"location":"stableCoin/standalone/ERC20/#description_2","text":"Returns the number of decimals used to get its user representation. For example, if decimals equals 2 , a balance of 505 tokens should be displayed to a user as 5,05 ( 505 / 10 ** 2 ). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless { setupDecimals} is called. NOTE: This information is only used for _display purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/ERC20/#description_3","text":"See {IERC20-totalSupply}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/ERC20/#description_4","text":"See {IERC20-balanceOf}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-transfer","text":"transfer(address recipient, uint256 amount) \u2192 bool","title":"Function: transfer"},{"location":"stableCoin/standalone/ERC20/#description_5","text":"See {IERC20-transfer}. Requirements: - recipient cannot be the zero address. - the caller must have a balance of at least amount .","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-allowance","text":"allowance(address owner, address spender) \u2192 uint256","title":"Function: allowance"},{"location":"stableCoin/standalone/ERC20/#description_6","text":"See {IERC20-allowance}.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-approve","text":"approve(address spender, uint256 amount) \u2192 bool","title":"Function: approve"},{"location":"stableCoin/standalone/ERC20/#description_7","text":"See {IERC20-approve}. Requirements: - spender cannot be the zero address.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-transferfrom","text":"transferFrom(address sender, address recipient, uint256 amount) \u2192 bool","title":"Function: transferFrom"},{"location":"stableCoin/standalone/ERC20/#description_8","text":"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - sender and recipient cannot be the zero address. - sender must have a balance of at least amount . - the caller must have allowance for sender 's tokens of at least amount .","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-increaseallowance","text":"increaseAllowance(address spender, uint256 addedValue) \u2192 bool","title":"Function: increaseAllowance"},{"location":"stableCoin/standalone/ERC20/#description_9","text":"Atomically increases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address.","title":"Description"},{"location":"stableCoin/standalone/ERC20/#function-decreaseallowance","text":"decreaseAllowance(address spender, uint256 subtractedValue) \u2192 bool","title":"Function: decreaseAllowance"},{"location":"stableCoin/standalone/ERC20/#description_10","text":"Atomically decreases the allowance granted to spender by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - spender cannot be the zero address. - spender must have allowance for the caller of at least subtractedValue .","title":"Description"},{"location":"stableCoin/standalone/IDoubleProxy/","text":"IDoubleProxy Functions: proxy() Function: proxy proxy() \u2192 address","title":"IDoubleProxy"},{"location":"stableCoin/standalone/IDoubleProxy/#idoubleproxy","text":"","title":"IDoubleProxy"},{"location":"stableCoin/standalone/IDoubleProxy/#functions","text":"proxy()","title":"Functions:"},{"location":"stableCoin/standalone/IDoubleProxy/#function-proxy","text":"proxy() \u2192 address","title":"Function: proxy"},{"location":"stableCoin/standalone/IERC20/","text":"IERC20 Interface of the ERC20 standard as defined in the EIP. Functions: totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount) Events: Transfer(address from, address to, uint256 value) Approval(address owner, address spender, uint256 value) Function: totalSupply totalSupply() \u2192 uint256 Description Returns the amount of tokens in existence. Function: balanceOf balanceOf(address account) \u2192 uint256 Description Returns the amount of tokens owned by account . Function: transfer transfer(address recipient, uint256 amount) \u2192 bool Description Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event. Function: allowance allowance(address owner, address spender) \u2192 uint256 Description Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called. Function: approve approve(address spender, uint256 amount) \u2192 bool Description Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event. Function: transferFrom transferFrom(address sender, address recipient, uint256 amount) \u2192 bool Description Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event. Event: Transfer Transfer(address from, address to, uint256 value) Description Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero. Event: Approval Approval(address owner, address spender, uint256 value) Description Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"IERC20"},{"location":"stableCoin/standalone/IERC20/#ierc20","text":"Interface of the ERC20 standard as defined in the EIP.","title":"IERC20"},{"location":"stableCoin/standalone/IERC20/#functions","text":"totalSupply() balanceOf(address account) transfer(address recipient, uint256 amount) allowance(address owner, address spender) approve(address spender, uint256 amount) transferFrom(address sender, address recipient, uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/IERC20/#events","text":"Transfer(address from, address to, uint256 value) Approval(address owner, address spender, uint256 value)","title":"Events:"},{"location":"stableCoin/standalone/IERC20/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/IERC20/#description","text":"Returns the amount of tokens in existence.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/IERC20/#description_1","text":"Returns the amount of tokens owned by account .","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-transfer","text":"transfer(address recipient, uint256 amount) \u2192 bool","title":"Function: transfer"},{"location":"stableCoin/standalone/IERC20/#description_2","text":"Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-allowance","text":"allowance(address owner, address spender) \u2192 uint256","title":"Function: allowance"},{"location":"stableCoin/standalone/IERC20/#description_3","text":"Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-approve","text":"approve(address spender, uint256 amount) \u2192 bool","title":"Function: approve"},{"location":"stableCoin/standalone/IERC20/#description_4","text":"Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#function-transferfrom","text":"transferFrom(address sender, address recipient, uint256 amount) \u2192 bool","title":"Function: transferFrom"},{"location":"stableCoin/standalone/IERC20/#description_5","text":"Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#event-transfer","text":"Transfer(address from, address to, uint256 value)","title":"Event: Transfer"},{"location":"stableCoin/standalone/IERC20/#description_6","text":"Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero.","title":"Description"},{"location":"stableCoin/standalone/IERC20/#event-approval","text":"Approval(address owner, address spender, uint256 value)","title":"Event: Approval"},{"location":"stableCoin/standalone/IERC20/#description_7","text":"Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"Description"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/","text":"IMVDFunctionalitiesManager Functions: isAuthorizedFunctionality(address functionality) Function: isAuthorizedFunctionality isAuthorizedFunctionality(address functionality) \u2192 bool","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#imvdfunctionalitiesmanager","text":"","title":"IMVDFunctionalitiesManager"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#functions","text":"isAuthorizedFunctionality(address functionality)","title":"Functions:"},{"location":"stableCoin/standalone/IMVDFunctionalitiesManager/#function-isauthorizedfunctionality","text":"isAuthorizedFunctionality(address functionality) \u2192 bool","title":"Function: isAuthorizedFunctionality"},{"location":"stableCoin/standalone/IMVDProxy/","text":"IMVDProxy Functions: getToken() getMVDFunctionalitiesManagerAddress() getMVDWalletAddress() getStateHolderAddress() submit(string codeName, bytes data) Function: getToken getToken() \u2192 address Function: getMVDFunctionalitiesManagerAddress getMVDFunctionalitiesManagerAddress() \u2192 address Function: getMVDWalletAddress getMVDWalletAddress() \u2192 address Function: getStateHolderAddress getStateHolderAddress() \u2192 address Function: submit submit(string codeName, bytes data) \u2192 bytes returnData","title":"IMVDProxy"},{"location":"stableCoin/standalone/IMVDProxy/#imvdproxy","text":"","title":"IMVDProxy"},{"location":"stableCoin/standalone/IMVDProxy/#functions","text":"getToken() getMVDFunctionalitiesManagerAddress() getMVDWalletAddress() getStateHolderAddress() submit(string codeName, bytes data)","title":"Functions:"},{"location":"stableCoin/standalone/IMVDProxy/#function-gettoken","text":"getToken() \u2192 address","title":"Function: getToken"},{"location":"stableCoin/standalone/IMVDProxy/#function-getmvdfunctionalitiesmanageraddress","text":"getMVDFunctionalitiesManagerAddress() \u2192 address","title":"Function: getMVDFunctionalitiesManagerAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-getmvdwalletaddress","text":"getMVDWalletAddress() \u2192 address","title":"Function: getMVDWalletAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-getstateholderaddress","text":"getStateHolderAddress() \u2192 address","title":"Function: getStateHolderAddress"},{"location":"stableCoin/standalone/IMVDProxy/#function-submit","text":"submit(string codeName, bytes data) \u2192 bytes returnData","title":"Function: submit"},{"location":"stableCoin/standalone/IStableCoin/","text":"IStableCoin Define the interface for the $usD The core idea behind Unified Stable Coin is to implement a stable coin collateralized by pools of whitelisted stable coins on UniSwap. By hedging across several pools and implementing simple yet effective rebalancing schemes, $uSD is able reduce an holder exposure to a stable-coin failure. Functions: init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount) Function: init init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Description Constructor signature Parameters: name : name of the StableCoin ERC20 token symbol : ticker for the StableCoin ERC20 token doubleProxy : address for the DoubleProxy allowedPairs : array of Uniswap Pairs to be set as whitelisted source tokens rebalanceRewardMultiplier : multiplier used to compute how many unifi tokens to mint during $uSD rebalance timeWindows : time windows inside which some time-delimited operations can be performed mintables : max amount of mintables inside a timeWindow Function: allowedPairs allowedPairs() \u2192 address[] Return Values: Array of allowed Uniswap pairs Function: availableToMint availableToMint() \u2192 uint256 mintable Return Values: mintable The amount of available mintable token Function: differences differences() \u2192 uint256, uint256 Function: doubleProxy doubleProxy() \u2192 address Return Values: The address for the doubleProxy smart contract Function: rebalanceRewardMultiplier rebalanceRewardMultiplier() \u2192 uint256[] Return Values: The multiplier used to compute the rebalancing rewards Function: tierData tierData() \u2192 uint256[], uint256[] Return Values: All tiers of data of the carried context Function: setAllowedPairs setAllowedPairs(address[] newAllowedPairs) Parameters: newAllowedPairs : list of Uniswap pairs to be whitelisted Function: setDoubleProxy setDoubleProxy(address newDoubleProxy) Parameters: newDoubleProxy : new DoubleProxy to set Function: calculateRebalanceByDebtReward calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward Description Compute the reward of the rebalanceByDebt() operation. Parameters: burnt : amount of of $uSD burnt Function: fromTokenToStable fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256 Description Convert from one of the allowed whitelisted tokens to $uSD Parameters: tokenAddress : Address of the token to convert amount : Amount of Unifi token to be converted Return Values: Amount of $uSD tokens Function: mint mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 Description Mint the $uSD token Parameters: pairIndex : Index of the pair inside the allowedPairs array amountA : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates) amountB : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates) amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired Return Values: Amount of freshly minted $uSD token Function: burn burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 amountA, uint256 amountB Description Mint the $uSD token Parameters: pairIndex : Index of the pair inside the allowedPairs array amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert Return Values: amountA The amount of tokenA received amountB The amount of tokenB received Function: rebalanceByCredit rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed Description Rebalance by Credit is triggered when the total amount of source tokens' is greater than $uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool. Function: rebalanceByDebt rebalanceByDebt(uint256 amount) \u2192 uint256 Description Rebalance by Debt is triggered when the total amount of source tokens' is lesser than $uSD circulating supply. Rebalancing is done by minting new equity ($unifi) at premium in exchange for burning $uSD.","title":"IStableCoin"},{"location":"stableCoin/standalone/IStableCoin/#istablecoin","text":"Define the interface for the $usD The core idea behind Unified Stable Coin is to implement a stable coin collateralized by pools of whitelisted stable coins on UniSwap. By hedging across several pools and implementing simple yet effective rebalancing schemes, $uSD is able reduce an holder exposure to a stable-coin failure.","title":"IStableCoin"},{"location":"stableCoin/standalone/IStableCoin/#functions","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/IStableCoin/#function-init","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: init"},{"location":"stableCoin/standalone/IStableCoin/#description","text":"Constructor signature","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters","text":"name : name of the StableCoin ERC20 token symbol : ticker for the StableCoin ERC20 token doubleProxy : address for the DoubleProxy allowedPairs : array of Uniswap Pairs to be set as whitelisted source tokens rebalanceRewardMultiplier : multiplier used to compute how many unifi tokens to mint during $uSD rebalance timeWindows : time windows inside which some time-delimited operations can be performed mintables : max amount of mintables inside a timeWindow","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-allowedpairs","text":"allowedPairs() \u2192 address[]","title":"Function: allowedPairs"},{"location":"stableCoin/standalone/IStableCoin/#return-values","text":"Array of allowed Uniswap pairs","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-availabletomint","text":"availableToMint() \u2192 uint256 mintable","title":"Function: availableToMint"},{"location":"stableCoin/standalone/IStableCoin/#return-values_1","text":"mintable The amount of available mintable token","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-differences","text":"differences() \u2192 uint256, uint256","title":"Function: differences"},{"location":"stableCoin/standalone/IStableCoin/#function-doubleproxy","text":"doubleProxy() \u2192 address","title":"Function: doubleProxy"},{"location":"stableCoin/standalone/IStableCoin/#return-values_2","text":"The address for the doubleProxy smart contract","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancerewardmultiplier","text":"rebalanceRewardMultiplier() \u2192 uint256[]","title":"Function: rebalanceRewardMultiplier"},{"location":"stableCoin/standalone/IStableCoin/#return-values_3","text":"The multiplier used to compute the rebalancing rewards","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-tierdata","text":"tierData() \u2192 uint256[], uint256[]","title":"Function: tierData"},{"location":"stableCoin/standalone/IStableCoin/#return-values_4","text":"All tiers of data of the carried context","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-setallowedpairs","text":"setAllowedPairs(address[] newAllowedPairs)","title":"Function: setAllowedPairs"},{"location":"stableCoin/standalone/IStableCoin/#parameters_1","text":"newAllowedPairs : list of Uniswap pairs to be whitelisted","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-setdoubleproxy","text":"setDoubleProxy(address newDoubleProxy)","title":"Function: setDoubleProxy"},{"location":"stableCoin/standalone/IStableCoin/#parameters_2","text":"newDoubleProxy : new DoubleProxy to set","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-calculaterebalancebydebtreward","text":"calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward","title":"Function: calculateRebalanceByDebtReward"},{"location":"stableCoin/standalone/IStableCoin/#description_1","text":"Compute the reward of the rebalanceByDebt() operation.","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_3","text":"burnt : amount of of $uSD burnt","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#function-fromtokentostable","text":"fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256","title":"Function: fromTokenToStable"},{"location":"stableCoin/standalone/IStableCoin/#description_2","text":"Convert from one of the allowed whitelisted tokens to $uSD","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_4","text":"tokenAddress : Address of the token to convert amount : Amount of Unifi token to be converted","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_5","text":"Amount of $uSD tokens","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-mint","text":"mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256","title":"Function: mint"},{"location":"stableCoin/standalone/IStableCoin/#description_3","text":"Mint the $uSD token","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_5","text":"pairIndex : Index of the pair inside the allowedPairs array amountA : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates) amountB : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates) amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_6","text":"Amount of freshly minted $uSD token","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-burn","text":"burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 amountA, uint256 amountB","title":"Function: burn"},{"location":"stableCoin/standalone/IStableCoin/#description_4","text":"Mint the $uSD token","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#parameters_6","text":"pairIndex : Index of the pair inside the allowedPairs array amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert","title":"Parameters:"},{"location":"stableCoin/standalone/IStableCoin/#return-values_7","text":"amountA The amount of tokenA received amountB The amount of tokenB received","title":"Return Values:"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancebycredit","text":"rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed","title":"Function: rebalanceByCredit"},{"location":"stableCoin/standalone/IStableCoin/#description_5","text":"Rebalance by Credit is triggered when the total amount of source tokens' is greater than $uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"Description"},{"location":"stableCoin/standalone/IStableCoin/#function-rebalancebydebt","text":"rebalanceByDebt(uint256 amount) \u2192 uint256","title":"Function: rebalanceByDebt"},{"location":"stableCoin/standalone/IStableCoin/#description_6","text":"Rebalance by Debt is triggered when the total amount of source tokens' is lesser than $uSD circulating supply. Rebalancing is done by minting new equity ($unifi) at premium in exchange for burning $uSD.","title":"Description"},{"location":"stableCoin/standalone/IStateHolder/","text":"IStateHolder Functions: getBool(string varName) getUint256(string varName) Function: getBool getBool(string varName) \u2192 bool Function: getUint256 getUint256(string varName) \u2192 uint256","title":"IStateHolder"},{"location":"stableCoin/standalone/IStateHolder/#istateholder","text":"","title":"IStateHolder"},{"location":"stableCoin/standalone/IStateHolder/#functions","text":"getBool(string varName) getUint256(string varName)","title":"Functions:"},{"location":"stableCoin/standalone/IStateHolder/#function-getbool","text":"getBool(string varName) \u2192 bool","title":"Function: getBool"},{"location":"stableCoin/standalone/IStateHolder/#function-getuint256","text":"getUint256(string varName) \u2192 uint256","title":"Function: getUint256"},{"location":"stableCoin/standalone/IUniswapV2Pair/","text":"IUniswapV2Pair Functions: decimals() totalSupply() token0() token1() balanceOf(address account) getReserves() Function: decimals decimals() \u2192 uint8 Function: totalSupply totalSupply() \u2192 uint256 Function: token0 token0() \u2192 address Function: token1 token1() \u2192 address Function: balanceOf balanceOf(address account) \u2192 uint256 Function: getReserves getReserves() \u2192 uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast","title":"IUniswapV2Pair"},{"location":"stableCoin/standalone/IUniswapV2Pair/#iuniswapv2pair","text":"","title":"IUniswapV2Pair"},{"location":"stableCoin/standalone/IUniswapV2Pair/#functions","text":"decimals() totalSupply() token0() token1() balanceOf(address account) getReserves()","title":"Functions:"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-decimals","text":"decimals() \u2192 uint8","title":"Function: decimals"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-totalsupply","text":"totalSupply() \u2192 uint256","title":"Function: totalSupply"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-token0","text":"token0() \u2192 address","title":"Function: token0"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-token1","text":"token1() \u2192 address","title":"Function: token1"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-balanceof","text":"balanceOf(address account) \u2192 uint256","title":"Function: balanceOf"},{"location":"stableCoin/standalone/IUniswapV2Pair/#function-getreserves","text":"getReserves() \u2192 uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast","title":"Function: getReserves"},{"location":"stableCoin/standalone/IUniswapV2Router/","text":"IUniswapV2Router Route liquidity back and forth an Uniswap Liquidity Pool. For more information see: https://uniswap.org/docs/v2/smart-contracts/router02/ Functions: getAmountsOut(uint256 amountIn, address[] path) removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) Function: getAmountsOut getAmountsOut(uint256 amountIn, address[] path) \u2192 uint256[] amounts Function: removeLiquidity removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB Description Removes liquidity from an ERC-20\u21c4ERC-20 pool https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity ===== Parameters: tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert to : Recipient of the underlying assets - deadline : Unix timestamp after which the transaction will revert Return Values: amountA The amount of tokenA received amountB The amount of tokenB received Function: addLiquidity addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB, uint256 liquidity Description Add Liquidity to an ERC-20\u21c4ERC-20 pool - To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB. - Always adds assets at the ideal ratio, according to the price when the transaction is executed. - If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added. https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity ===== Parameters: tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountADesired : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates). amountBDesired : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates). amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired. amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired. to : Recipient of the underlying assets - deadline : Unix timestamp after which the transaction will revert Return Values: amountA The amount of tokenA sent to the pool amountB The amount of tokenB sent to the pool liquidity The amount of liquidity tokens minted","title":"IUniswapV2Router"},{"location":"stableCoin/standalone/IUniswapV2Router/#iuniswapv2router","text":"Route liquidity back and forth an Uniswap Liquidity Pool. For more information see: https://uniswap.org/docs/v2/smart-contracts/router02/","title":"IUniswapV2Router"},{"location":"stableCoin/standalone/IUniswapV2Router/#functions","text":"getAmountsOut(uint256 amountIn, address[] path) removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline)","title":"Functions:"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-getamountsout","text":"getAmountsOut(uint256 amountIn, address[] path) \u2192 uint256[] amounts","title":"Function: getAmountsOut"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-removeliquidity","text":"removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB","title":"Function: removeLiquidity"},{"location":"stableCoin/standalone/IUniswapV2Router/#description","text":"Removes liquidity from an ERC-20\u21c4ERC-20 pool https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity =====","title":"Description"},{"location":"stableCoin/standalone/IUniswapV2Router/#parameters","text":"tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountAMin : The minimum amount of tokenA that must be received for the transaction not to revert amountBMin : The minimum amount of tokenB that must be received for the transaction not to revert to : Recipient of the underlying assets","title":"Parameters:"},{"location":"stableCoin/standalone/IUniswapV2Router/#-deadline-unix-timestamp-after-which-the-transaction-will-revert","text":"","title":"- deadline: Unix timestamp after which the transaction will revert"},{"location":"stableCoin/standalone/IUniswapV2Router/#return-values","text":"amountA The amount of tokenA received amountB The amount of tokenB received","title":"Return Values:"},{"location":"stableCoin/standalone/IUniswapV2Router/#function-addliquidity","text":"addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) \u2192 uint256 amountA, uint256 amountB, uint256 liquidity","title":"Function: addLiquidity"},{"location":"stableCoin/standalone/IUniswapV2Router/#description_1","text":"Add Liquidity to an ERC-20\u21c4ERC-20 pool - To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB. - Always adds assets at the ideal ratio, according to the price when the transaction is executed. - If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added. https://uniswap.org/docs/v2/smart-contracts/router02/#addliquidity =====","title":"Description"},{"location":"stableCoin/standalone/IUniswapV2Router/#parameters_1","text":"tokenA : A pool token tokenB : A pool token liquidity : The amount of liquidity tokens to remove amountADesired : The amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates). amountBDesired : The amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates). amountAMin : Bounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired. amountBMin : Bounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired. to : Recipient of the underlying assets","title":"Parameters:"},{"location":"stableCoin/standalone/IUniswapV2Router/#-deadline-unix-timestamp-after-which-the-transaction-will-revert_1","text":"","title":"- deadline: Unix timestamp after which the transaction will revert"},{"location":"stableCoin/standalone/IUniswapV2Router/#return-values_1","text":"amountA The amount of tokenA sent to the pool amountB The amount of tokenB sent to the pool liquidity The amount of liquidity tokens minted","title":"Return Values:"},{"location":"stableCoin/standalone/SafeMath/","text":"SafeMath Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. SafeMath restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always. Functions:","title":"SafeMath"},{"location":"stableCoin/standalone/SafeMath/#safemath","text":"Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. SafeMath restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.","title":"SafeMath"},{"location":"stableCoin/standalone/SafeMath/#functions","text":"","title":"Functions:"},{"location":"stableCoin/standalone/StableCoin/","text":"StableCoin Contract for the $uSD Stable Coin. It's an ERC20 token extended with the IStableCoin interface and DFO protocol magic. Functions: constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount) Function: constructor constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Description Contract constructor. See StableCoin.init() docs. Function: init init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) Function: allowedPairs allowedPairs() \u2192 address[] Function: availableToMint availableToMint() \u2192 uint256 Function: differences differences() \u2192 uint256 credit, uint256 debt Function: doubleProxy doubleProxy() \u2192 address Function: rebalanceRewardMultiplier rebalanceRewardMultiplier() \u2192 uint256[] Function: tierData tierData() \u2192 uint256[], uint256[] Function: setAllowedPairs setAllowedPairs(address[] newAllowedPairs) Function: setDoubleProxy setDoubleProxy(address newDoubleProxy) Function: calculateRebalanceByDebtReward calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward Function: fromTokenToStable fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256 Function: mint mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 minted Description Minting first check tha DFO auth protocol are respected, secondly it sends the tokens to a Uniswap Pool (_createPoolToken) Function: burn burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 removedA, uint256 removedB Function: rebalanceByCredit rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed Description Rebalance by Credit is triggered when the total amount of source tokens is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool. Function: rebalanceByDebt rebalanceByDebt(uint256 amount) \u2192 uint256 reward","title":"StableCoin"},{"location":"stableCoin/standalone/StableCoin/#stablecoin","text":"Contract for the $uSD Stable Coin. It's an ERC20 token extended with the IStableCoin interface and DFO protocol magic.","title":"StableCoin"},{"location":"stableCoin/standalone/StableCoin/#functions","text":"constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables) allowedPairs() availableToMint() differences() doubleProxy() rebalanceRewardMultiplier() tierData() setAllowedPairs(address[] newAllowedPairs) setDoubleProxy(address newDoubleProxy) calculateRebalanceByDebtReward(uint256 burnt) fromTokenToStable(address tokenAddress, uint256 amount) mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) rebalanceByDebt(uint256 amount)","title":"Functions:"},{"location":"stableCoin/standalone/StableCoin/#function-constructor","text":"constructor(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: constructor"},{"location":"stableCoin/standalone/StableCoin/#description","text":"Contract constructor. See StableCoin.init() docs.","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-init","text":"init(string name, string symbol, address doubleProxy, address[] allowedPairs, uint256[] rebalanceRewardMultiplier, uint256[] timeWindows, uint256[] mintables)","title":"Function: init"},{"location":"stableCoin/standalone/StableCoin/#function-allowedpairs","text":"allowedPairs() \u2192 address[]","title":"Function: allowedPairs"},{"location":"stableCoin/standalone/StableCoin/#function-availabletomint","text":"availableToMint() \u2192 uint256","title":"Function: availableToMint"},{"location":"stableCoin/standalone/StableCoin/#function-differences","text":"differences() \u2192 uint256 credit, uint256 debt","title":"Function: differences"},{"location":"stableCoin/standalone/StableCoin/#function-doubleproxy","text":"doubleProxy() \u2192 address","title":"Function: doubleProxy"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancerewardmultiplier","text":"rebalanceRewardMultiplier() \u2192 uint256[]","title":"Function: rebalanceRewardMultiplier"},{"location":"stableCoin/standalone/StableCoin/#function-tierdata","text":"tierData() \u2192 uint256[], uint256[]","title":"Function: tierData"},{"location":"stableCoin/standalone/StableCoin/#function-setallowedpairs","text":"setAllowedPairs(address[] newAllowedPairs)","title":"Function: setAllowedPairs"},{"location":"stableCoin/standalone/StableCoin/#function-setdoubleproxy","text":"setDoubleProxy(address newDoubleProxy)","title":"Function: setDoubleProxy"},{"location":"stableCoin/standalone/StableCoin/#function-calculaterebalancebydebtreward","text":"calculateRebalanceByDebtReward(uint256 burnt) \u2192 uint256 reward","title":"Function: calculateRebalanceByDebtReward"},{"location":"stableCoin/standalone/StableCoin/#function-fromtokentostable","text":"fromTokenToStable(address tokenAddress, uint256 amount) \u2192 uint256","title":"Function: fromTokenToStable"},{"location":"stableCoin/standalone/StableCoin/#function-mint","text":"mint(uint256 pairIndex, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 minted","title":"Function: mint"},{"location":"stableCoin/standalone/StableCoin/#description_1","text":"Minting first check tha DFO auth protocol are respected, secondly it sends the tokens to a Uniswap Pool (_createPoolToken)","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-burn","text":"burn(uint256 pairIndex, uint256 pairAmount, uint256 amountAMin, uint256 amountBMin) \u2192 uint256 removedA, uint256 removedB","title":"Function: burn"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancebycredit","text":"rebalanceByCredit(uint256 pairIndex, uint256 pairAmount, uint256 amountA, uint256 amountB) \u2192 uint256 redeemed","title":"Function: rebalanceByCredit"},{"location":"stableCoin/standalone/StableCoin/#description_2","text":"Rebalance by Credit is triggered when the total amount of source tokens is greater than uSD circulating supply. Rebalancing is done by withdrawing the excess from the pool.","title":"Description"},{"location":"stableCoin/standalone/StableCoin/#function-rebalancebydebt","text":"rebalanceByDebt(uint256 amount) \u2192 uint256 reward","title":"Function: rebalanceByDebt"}]}